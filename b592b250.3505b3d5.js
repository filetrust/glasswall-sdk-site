(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{202:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return p}));var n=a(2),r=a(6),i=(a(0),a(280)),l={title:"2.2.6.1.5.1 Archive Manager",sidebar_label:"2.2.6.1.5.1 Archive Manager"},b={unversionedId:"2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_1-archive-manager",id:"2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_1-archive-manager",isDocsHomePage:!1,title:"2.2.6.1.5.1 Archive Manager",description:"Overview",source:"@site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_1-archive-manager.md",slug:"/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_1-archive-manager",permalink:"/glasswall-sdk-site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_1-archive-manager",version:"current",sidebar_label:"2.2.6.1.5.1 Archive Manager",sidebar:"someSidebar",previous:{title:"2.2.6.1.4.4 Examples",permalink:"/glasswall-sdk-site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_4-wordsearch/2_2_6_1_4_4-exampleuseage"},next:{title:"2.2.6.1.5.2 Archive Manager Config",permalink:"/glasswall-sdk-site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_2-config"}},c=[{value:"Overview",id:"overview",children:[{value:"Supported Archive Types",id:"supported-archive-types",children:[]}]},{value:"Processing Modes",id:"processing-modes",children:[{value:"Analysis",id:"analysis",children:[]},{value:"Protect",id:"protect",children:[]},{value:"Export and Import",id:"export-and-import",children:[]}]},{value:"Examples",id:"examples",children:[]},{value:"API",id:"api",children:[{value:"GwFileProtectAndReportArchive",id:"gwfileprotectandreportarchive",children:[]},{value:"GwFileAnalysisArchive",id:"gwfileanalysisarchive",children:[]},{value:"GwFileExportArchive",id:"gwfileexportarchive",children:[]},{value:"GwFileImportArchive",id:"gwfileimportarchive",children:[]},{value:"GwArchiveDone",id:"gwarchivedone",children:[]}]}],o={rightToc:c};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"overview"},"Overview"),Object(i.b)("p",null,"The Glasswall Archive Manager is a wrapper around the Glasswall CDR (Content Disarm and Reconstruction) Engine. It provides support for Archive file formats by extracting the input archive and handing each file within the archive to the Glasswall engine for processing. The regenerated, exported, imported files or XML analysis reports are then packaged in a brand new archive while preserving the directory structure of the original archive."),Object(i.b)("h3",{id:"supported-archive-types"},"Supported Archive Types"),Object(i.b)("p",null,"The table below lists the archive formats supported by Glasswall Archive Manager:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Archive Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"7Zip"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Open architecture compression")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"BZip2"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"open-source file compression")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"GZip"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Compression for GNU")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Rar (Decompression only)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Roshal Archive compression")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tar"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Tape Archive")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Zip"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Lossless data compression")))),Object(i.b)("h2",{id:"processing-modes"},"Processing Modes"),Object(i.b)("p",null,"There are four processing modes, Analysis, Protect, Export and Import."),Object(i.b)("h3",{id:"analysis"},"Analysis"),Object(i.b)("p",null,"The input archive is decompressed, each file within the archive is passed to the Glasswall engine for processing in analysis mode, the resulting XML analysis reports are repackaged in a new archive while preserving the original directory structure."),Object(i.b)("h3",{id:"protect"},"Protect"),Object(i.b)("p",null,"The input archive is decompressed, each file within the archive is passed to the Glasswall CDR engine for processing in protect mode, the regenerated files are repackaged in a new archive while preserving the original directory structure."),Object(i.b)("h3",{id:"export-and-import"},"Export and Import"),Object(i.b)("p",null,"The Glasswall engine provides the ability to export and import the engine's internal representation of a file structure in an intermediate format such as XML or SISL. This allows internal components of a file to be made available to external programs for additional processing, before recomposing the file to include those externally modified components with a call to ",Object(i.b)("strong",{parentName:"p"},"import")," API."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE:")," These modes are only supported when the archive manager is used with the Editor SDK."),Object(i.b)("h4",{id:"export"},"Export"),Object(i.b)("p",null,"Files are processed as follows in this mode: "),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The input archive is decompressed "),Object(i.b)("li",{parentName:"ul"},"Each file within the archive is passed to the Glasswall engine for processing in export mode. Each export package will consist of XML/SISL files which make up each processed input file. "),Object(i.b)("li",{parentName:"ul"},"The resulting export packages are repackaged in a new archive while preserving the original directory structure.")),Object(i.b)("h4",{id:"import"},"Import"),Object(i.b)("p",null,"Files are processed as follows in this mode: "),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The input archive is decompressed"),Object(i.b)("li",{parentName:"ul"},"Each export package within the archive is passed to the Glasswall engine for processing in import mode, the resulting generated files are repackaged in a new archive while preserving the original directory structure. ")),Object(i.b)("h2",{id:"examples"},"Examples"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"/glasswall-sdk-site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_2-config"}),"Config Example")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"/glasswall-sdk-site/docs/2-glasswall_core/2_2-glasswall_editor/2_2_6-sdk/2_2_6_1-api/2_2_6_1_5-archivemanager/2_2_6_1_5_3-example"}),"Usage Example"))),Object(i.b)("h2",{id:"api"},"API"),Object(i.b)("p",null,"Each of the APIs returns a ",Object(i.b)("inlineCode",{parentName:"p"},"Status")," type, which is defined as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-c++"}),"enum Status {\n    eFail,\n    eSuccess\n};\n")),Object(i.b)("h3",{id:"gwfileprotectandreportarchive"},"GwFileProtectAndReportArchive"),Object(i.b)("p",null,"This is used to call the archive manager, process the specified input archive and produce an output archive along with a report."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"status_t GwFileProtectAndReportArchive(\n    void *inputBuffer, \n    size_t inputBufferLength, \n    void **outputFileBuffer, \n    size_t *outputFileBufferLength, \n    void **outputReportBuffer, \n    size_t *outputReportBufferLength, \n    const char *xmlConfigString\n    )\n")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Direction"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the input file to be processed")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The size of the input file buffer")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the processed file buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the output file buffer. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the archive manager report buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the archive manager report. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"xmlConfigString"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"const char *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the content management XML file. This buffer needs to be null terminated")))),Object(i.b)("h3",{id:"gwfileanalysisarchive"},"GwFileAnalysisArchive"),Object(i.b)("p",null,"This is used to call the archive manager, process the specified input archive and produce a package (archive) containing reports\nfor each file within the processed input archive, as well as a general report for the input archive."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"status_t GwFileAnalysisArchive(\n    void *inputBuffer, \n    size_t inputBufferLength, \n    void **outputFileBuffer, \n    size_t *outputFileBufferLength, \n    void **outputAnalysisReportBuffer, \n    size_t *outputAnalysisReportBufferLength, \n    const char *xmlConfigString\n    )\n")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Direction"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the input file to be processed")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The size of the input file buffer")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the resulting archive. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the output file buffer. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputAnalysisReportBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the archive manager report buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputAnalysisReportBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the archive manager report. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"xmlConfigString"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"const char *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the content management XML file. This buffer needs to be null terminated")))),Object(i.b)("h3",{id:"gwfileexportarchive"},"GwFileExportArchive"),Object(i.b)("p",null,"This is used to call the archive manager, process the specified input archive and produce ",Object(i.b)("strong",{parentName:"p"},"export")," packages containing the internals of a each file within the archive. "),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"status_t GwFileExportArchive(\n    void *inputBuffer, \n    size_t inputBufferLength, \n    void **outputFileBuffer, \n    size_t *outputFileBufferLength, \n    void **outputReportBuffer, \n    size_t *outputReportBufferLength, \n    const char *xmlConfigString\n    )\n")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Direction"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the input file to be processed")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The size of the input file buffer")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the processed file buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the output file buffer. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the archive manager report buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the archive manager report. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"xmlConfigString"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"const char *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the content management XML file. This buffer needs to be null terminated")))),Object(i.b)("h3",{id:"gwfileimportarchive"},"GwFileImportArchive"),Object(i.b)("p",null,"This is used to call the archive manager, process each ",Object(i.b)("strong",{parentName:"p"},"export package")," (containing internals of each file) and regenerate output archive containing reconstructed files."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"status_t GwFileImportArchive(\n    void *inputBuffer, \n    size_t inputBufferLength, \n    void **outputFileBuffer, \n    size_t *outputFileBufferLength, \n    void **outputReportBuffer, \n    size_t *outputReportBufferLength, \n    const char *xmlConfigString\n    )\n")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Direction"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the input file to be processed")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"inputBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The size of the input file buffer")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the processed file buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputFileBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the output file buffer. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBuffer"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"void **")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to a pointer to a buffer that will be populated with the archive manager report buffer. This buffer is allocated by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"outputReportBufferLength"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"size_t *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Out"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the size of the archive manager report. This will be set by the archive manager")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"xmlConfigString"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("inlineCode",{parentName:"td"},"const char *")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"In"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"A pointer to the buffer containing the content management XML file. This buffer needs to be null terminated")))),Object(i.b)("h3",{id:"gwarchivedone"},"GwArchiveDone"),Object(i.b)("p",null,"This is used to release any resources that have been allocated by the archive manager. This function needs to be called after each call made to the 'GwFileAnalysisArchive' or 'GwFileProtectAndReportArchive' function otherwise memory leaks may occur."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"void GwArchiveDone()\n")))}p.isMDXComponent=!0},280:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return O}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),p=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},u=function(e){var t=p(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},s=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),u=p(a),s=n,O=u["".concat(l,".").concat(s)]||u[s]||d[s]||i;return a?r.a.createElement(O,b(b({ref:t},o),{},{components:a})):r.a.createElement(O,b({ref:t},o))}));function O(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=s;var b={};for(var c in t)hasOwnProperty.call(t,c)&&(b[c]=t[c]);b.originalType=e,b.mdxType="string"==typeof e?e:n,l[1]=b;for(var o=2;o<i;o++)l[o]=a[o];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}s.displayName="MDXCreateElement"}}]);