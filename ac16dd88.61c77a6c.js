(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{179:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));var a=n(2),i=n(6),r=(n(0),n(234)),o={title:"Glasswall C Coding Guidelines"},l={unversionedId:"5-development/artifacts/glasswall_c_coding_guidelines",id:"5-development/artifacts/glasswall_c_coding_guidelines",isDocsHomePage:!1,title:"Glasswall C Coding Guidelines",description:"1. THE C PROGRAMMING LANGUAGE",source:"@site/docs/5-development/artifacts/glasswall_c_coding_guidelines.md",slug:"/5-development/artifacts/glasswall_c_coding_guidelines",permalink:"/glasswall-sdk-site/docs/5-development/artifacts/glasswall_c_coding_guidelines",version:"current"},c=[{value:"1. THE C PROGRAMMING LANGUAGE",id:"1-the-c-programming-language",children:[]},{value:"2. INTRODUCTION",id:"2-introduction",children:[{value:"2.1 Objective",id:"21-objective",children:[]},{value:"2.2 Applicability",id:"22-applicability",children:[]},{value:"2.3 Nomenclature",id:"23-nomenclature",children:[]}]},{value:"3. REFERENCED DOCUMENTS",id:"3-referenced-documents",children:[]},{value:"4. C PROGRAM STRUCTURE",id:"4-c-program-structure",children:[]},{value:'5. <a name="5"></a> CODE HEADERS',id:"5--code-headers",children:[{value:"5.1 Element Header",id:"51-element-header",children:[]},{value:"5.2 Unit Header",id:"52-unit-header",children:[]}]},{value:"6 CODE LAYOUT",id:"6-code-layout",children:[{value:"6.1 Module Layout",id:"61-module-layout",children:[]},{value:"6.2 Bracketing",id:"62-bracketing",children:[]},{value:"6.3 Keywords",id:"63-keywords",children:[]},{value:"6.4 Subroutines and Variables",id:"64-subroutines-and-variables",children:[]},{value:"6.5 Line Lengths",id:"65-line-lengths",children:[]},{value:"6.6 Indentation",id:"66-indentation",children:[]},{value:"6.7 Tabs",id:"67-tabs",children:[]},{value:"6.8 Blocks",id:"68-blocks",children:[]},{value:"6.9 Chunking",id:"69-chunking",children:[]},{value:"6.10 Vertical Alignment",id:"610-vertical-alignment",children:[]},{value:"6.11 Breaking Long Lines",id:"611-breaking-long-lines",children:[]},{value:"6.12 Breaking by Precedence",id:"612-breaking-by-precedence",children:[]},{value:"6.13 Assignments",id:"613-assignments",children:[]},{value:"6.14 Automated Layout",id:"614-automated-layout",children:[]}]},{value:"7 C IMPLEMENTATION",id:"7-c-implementation",children:[{value:"7.1 Header Files",id:"71-header-files",children:[]},{value:"7.2 Header File Content",id:"72-header-file-content",children:[]},{value:"7.3 Goto",id:"73-goto",children:[]},{value:"7.4 Functions",id:"74-functions",children:[]},{value:"7.5 Null Pointers",id:"75-null-pointers",children:[]},{value:"7.6 Preprocessor",id:"76-preprocessor",children:[]},{value:"7.7 Booleans",id:"77-booleans",children:[]},{value:"7.8 Pointer Declarations",id:"78-pointer-declarations",children:[]}]},{value:"8 NAMING CONVENTIONS",id:"8-naming-conventions",children:[{value:"8.1 Identifiers",id:"81-identifiers",children:[]},{value:"8.2 Booleans",id:"82-booleans",children:[]},{value:"8.3 Pointer Variables",id:"83-pointer-variables",children:[]},{value:"8.4 Arrays",id:"84-arrays",children:[]},{value:"8.5 Multiword Identifiers",id:"85-multiword-identifiers",children:[]},{value:"8.6 Abbreviations",id:"86-abbreviations",children:[]}]},{value:"8.7 Ambiguous Abbreviations",id:"87-ambiguous-abbreviations",children:[{value:"8.8 Ambiguous Names",id:"88-ambiguous-names",children:[]},{value:"8.9 General Naming Conventions",id:"89-general-naming-conventions",children:[]}]},{value:"9 DOCUMENTATION",id:"9-documentation",children:[{value:"9.1 Algorithmic Documentation",id:"91-algorithmic-documentation",children:[]},{value:"9.2 Elucidating Comments",id:"92-elucidating-comments",children:[]},{value:"9.3 Defensive Documentation",id:"93-defensive-documentation",children:[]},{value:"9.4 Indicative Documentation",id:"94-indicative-documentation",children:[]},{value:"9.5 Proofreading",id:"95-proofreading",children:[]}]},{value:"10 LIBRARY FUNCTIONS",id:"10-library-functions",children:[{value:"10.1 &lt;assert.h&gt;",id:"101-asserth",children:[]},{value:"10.2 &lt;ctype.h&gt;",id:"102-ctypeh",children:[]},{value:"10.3 &lt;errno.h&gt;",id:"103-errnoh",children:[]},{value:"10.4 &lt;float.h&gt;",id:"104-floath",children:[]},{value:"10.5 &lt;limits.h&gt;",id:"105-limitsh",children:[]},{value:"10.6 &lt;locale.h&gt;",id:"106-localeh",children:[]},{value:"10.7 &lt;math.h&gt;",id:"107-mathh",children:[]},{value:"10.8 &lt;setjmp.h&gt;",id:"108-setjmph",children:[]},{value:"10.9 &lt;signal.h&gt;",id:"109-signalh",children:[]},{value:"10.10 &lt;stdarg.h&gt;",id:"1010-stdargh",children:[]},{value:"10.11 &lt;stddef.h&gt;",id:"1011-stddefh",children:[]},{value:"10.12 &lt;stdio.h&gt;",id:"1012-stdioh",children:[]},{value:"10.13 &lt;stdlib.h&gt;",id:"1013-stdlibh",children:[]},{value:"10.14 &lt;string.h&gt;",id:"1014-stringh",children:[]},{value:"10.15 &lt;time.h&gt;",id:"1015-timeh",children:[]}]},{value:"11 SUPPORT LIBRARIES",id:"11-support-libraries",children:[]},{value:"12 ERROR HANDLING",id:"12-error-handling",children:[{value:"12.1 Function",id:"121-function",children:[]}]},{value:"13 VALUES AND EXPRESSIONS",id:"13-values-and-expressions",children:[{value:"13.1 Leading Zeros",id:"131-leading-zeros",children:[]},{value:"13.2 Multiline Strings",id:"132-multiline-strings",children:[]},{value:"13.3 Comma Operator",id:"133-comma-operator",children:[]},{value:"13.4 Constants",id:"134-constants",children:[]}]},{value:"14 VARIABLES",id:"14-variables",children:[{value:"14.1 Global Variables",id:"141-global-variables",children:[]},{value:"14.2 Initialisation",id:"142-initialisation",children:[]},{value:"14.3 Scope",id:"143-scope",children:[]}]},{value:"15 CONTROL STRUCTURES",id:"15-control-structures",children:[{value:"15.1 Linear Coding",id:"151-linear-coding",children:[]}]},{value:"16 UNDEFINED BEHAVIOURS",id:"16-undefined-behaviours",children:[{value:"16.1 Lexical Conventions - Constants -- Character Constants",id:"161-lexical-conventions---constants----character-constants",children:[]},{value:"16.2 Lexical Conventions -- String Literals",id:"162-lexical-conventions----string-literals",children:[]},{value:"16.3 Conversions \u2014 Integer and Floating",id:"163-conversions--integer-and-floating",children:[]},{value:"16.4 Conversions \u2014 Floating Types",id:"164-conversions--floating-types",children:[]},{value:"16.5 Expressions - Postfix Expressions - Function Calls",id:"165-expressions---postfix-expressions---function-calls",children:[]},{value:"16.6 Expressions - Multiplicative Operators",id:"166-expressions---multiplicative-operators",children:[]},{value:"16.7 Expressions - Additive Operators",id:"167-expressions---additive-operators",children:[]},{value:"16.8 Expressions - Shift Operators",id:"168-expressions---shift-operators",children:[]},{value:"16.9 Expressions - Relational Operators",id:"169-expressions---relational-operators",children:[]},{value:"16.10 Preprocessing",id:"1610-preprocessing",children:[]}]},{value:"16.11 Preprocessing - Macro Definition and Expansion",id:"1611-preprocessing---macro-definition-and-expansion",children:[{value:"16.12 Preprocessing - File Inclusion",id:"1612-preprocessing---file-inclusion",children:[]},{value:"16.13 Input and Output: <code>&lt;stdio.h</code>&gt; - File Operations",id:"1613-input-and-output-stdioh---file-operations",children:[]},{value:"16.14 Input and Output: <code>&lt;stdio.h&gt;</code> - Formatted Output",id:"1614-input-and-output-stdioh---formatted-output",children:[]},{value:"16.15 String Functions: <code>&lt;string.h&gt;</code>",id:"1615-string-functions-stringh",children:[]},{value:"16.16 Linkages of Identifiers",id:"1616-linkages-of-identifiers",children:[]},{value:"16.17 Storage Duration of Objects",id:"1617-storage-duration-of-objects",children:[]},{value:"16.19 Expressions - Postfix Operators - Function Calls",id:"1619-expressions---postfix-operators---function-calls",children:[]},{value:"16.20 Character Handling",id:"1620-character-handling",children:[]},{value:"16.21 Environment - Hosted Environment",id:"1621-environment---hosted-environment",children:[]}]},{value:"17 USEFUL MACRO AND FUNCTION EXAMPLES",id:"17-useful-macro-and-function-examples",children:[{value:"17.1 Macros",id:"171-macros",children:[]},{value:"17.2 Functions",id:"172-functions",children:[]}]},{value:"18 TOOL SUPPORT",id:"18-tool-support",children:[]},{value:"19 TESTS",id:"19-tests",children:[]},{value:"20 C CODING GUIDELINES",id:"20-c-coding-guidelines",children:[]}],b={rightToc:c};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"1-the-c-programming-language"},"1. THE C PROGRAMMING LANGUAGE"),Object(r.b)("p",null,"Dennis Ritchie developed the original version of the programming language C at AT&T Bell Laboratories in the early 1970s."),Object(r.b)("p",null,"The American National Standards Institute, or ANSI, standardises computer programming languages\nin the United States. X3J11 is the name of the ANSI-authorised committee that developed the standard for C, starting in 1983."),Object(r.b)("p",null,"The International Standards Organisation, or ISO, C has a similar responsibility in the\ninternational arena. ISO formed the technical committee JTC1/SC22/WG14 to review and augment\nthe work of X3J11."),Object(r.b)("p",null,"By 1992, ISO had adopted a standard for C that was essentially identical to X3.159. It\nis called ISO 9899:1990. The C standards differ only in format and in the numbering of sections. The wording differs in a few small places but makes no substantive difference to the language definition."),Object(r.b)("p",null,"These Guidelines pertain to C, as defined by ISO 9899:1990."),Object(r.b)("h2",{id:"2-introduction"},"2. INTRODUCTION"),Object(r.b)("h3",{id:"21-objective"},"2.1 Objective"),Object(r.b)("p",null,"The objective of C Coding Guidelines is to ensure all C programs\nproduced by, or on behalf of, Glasswall Solutions Ltd, have a clear and\nconsistent coding style. It is also designed to help write portable C."),Object(r.b)("p",null,"Portability is about minimising the cost of transferring functionality\nfrom one system to another. This can be achieved by keeping the codebase\nwithin the feature set guaranteed to be available on all implementations\nthat conform to a particular, widely-implemented, standard, in this\ncase, ISO/IEC 9899:1990."),Object(r.b)("p",null,"Writing for portability is about refusing to increase the ",Object(r.b)("em",{parentName:"p"},"unnecessary"),"\ncosts of porting the code."),Object(r.b)("p",null,"Therefore, these Guidelines mandate where possible, best practices for\nwriting portable C code, pointing out pitfalls, common misconceptions,\nand errors and suggests remedies. The Guidelines are not confined to\nthat though. They are also comprised of various aspects of the art of\ncoding, including layout, and name selection. The Guidelines are\ndesigned to produce code that is clear, robust, efficient, maintainable,\nand concise."),Object(r.b)("h3",{id:"22-applicability"},"2.2 Applicability"),Object(r.b)("p",null,"This Standard shall be applied to all C code written by, or on behalf\nof, Glasswall Solutions Ltd, except where:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The customer requires, and Glasswall Solutions Ltd accepts, the\nuse of a different procedure, or")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The project can demonstrate, and Glasswall Solutions Ltd\naccepts, that these Coding Guidelines are inappropriate for the\nproject and that acceptable alternative Guidelines are available."))),Object(r.b)("h3",{id:"23-nomenclature"},"2.3 Nomenclature"),Object(r.b)("p",null,"Lucida Console is used for any source code related information. This is\nto distinguish it from normal text, and to obviate problems in other\nfonts for reading names such as"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"lInfoFlag1\n")),Object(r.b)("p",null,"which is actually"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"lInfoFlag1\n")),Object(r.b)("p",null,"(lowercase L and uppercase i look the some in quite a few fonts).\nCourier would have served just as well:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"lInfoFlag1\n")),Object(r.b)("p",null,"Depending on context, the word ",Object(r.b)("em",{parentName:"p"},"bracket")," is used to indicate any of the\npaired delimiters ",Object(r.b)("inlineCode",{parentName:"p"},"()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"{}"),", ",Object(r.b)("inlineCode",{parentName:"p"},"\\[\\]"),"."),Object(r.b)("p",null,"Code examples are generally shown in a box with a grey background, using\nLucinda Console font. Sometimes short examples are included in the text\nin a monospaced font."),Object(r.b)("h2",{id:"3-referenced-documents"},"3. REFERENCED DOCUMENTS"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"ISO/IEC 9899:1990 Programming languages - C"),Object(r.b)("br",null),"\nThis Standard was amended and corrected by ISO/IEC 9899/COR1:1994,\nISO/IEC 9899/AMD1:1995, and ISO/IEC 9899/ COR2:1996.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"The C Programming Language"),Object(r.b)("br",null),"\n2nd Edition. B.W. Kernighan and D.M. Ritchie. Prentice Hall, 1988")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"Software Engineering"),Object(r.b)("br",null),"\n2nd Edition. lan Sommerville, 1985")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"Perl Best Practices"),Object(r.b)("br",null),"\nDamian Conway. O'Reilly, 2005",Object(r.b)("br",null),"\nMany of the best practices in this book are pertinent to other programming languages.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"The Standard C Library"),Object(r.b)("br",null),"\nP.J. Plauger, Prentice Hall, 1992",Object(r.b)("br",null),"\nThis book exlains how the library was ",Object(r.b)("em",{parentName:"p"},"meant")," to be used and how it\n",Object(r.b)("em",{parentName:"p"},"can")," be used, and how to implement it, providing approximately 9,000\nlines of tested working code that is highly portable and exemplary.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"C Programming FAQs: Frequently Asked Questions"),Object(r.b)("br",null),"\nSteve Summit, Addison Wesley, 1996",Object(r.b)("br",null),"\nThis book addresses over 400 questions providing accurate, insightful,\nexplanations and clarification of all aspects of C, with numerous code\nexamples.")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"MISRA-C:2004: Guidelines for the use of the C language in critical systems"),Object(r.b)("br",null),"\nMIRA, 2004",Object(r.b)("br",null),"\nAlthough designed for safety critical systems, there are many guidelines\npertinent to non-safety critical systems."))),Object(r.b)("h2",{id:"4-c-program-structure"},"4. C PROGRAM STRUCTURE"),Object(r.b)("p",null,"A C program is the equivalent of a program task as defined in most\nSoftware Structural Design Specifications (SDSs). A specification for an\nSDS should be drawn-up for Glasswall Solutions Ltd (unless one exists)."),Object(r.b)("p",null,"A C program consists of a set of external objects, which are either\nvariables or functions."),Object(r.b)("p",null,"A C program may reside in one or more source files, and header files.\nSource files may be compiled separately and loaded together, along with\npreviously compiled functions from libraries."),Object(r.b)("h2",{id:"5--code-headers"},"5. ",Object(r.b)("a",{name:"5"})," CODE HEADERS"),Object(r.b)("p",null,"This section defines how the header information shall be provided for in\nC programs."),Object(r.b)("h3",{id:"51-element-header"},"5.1 Element Header"),Object(r.b)("p",null,"In C terminology, elements are header files or source files."),Object(r.b)("h4",{id:"511-source-file-element-header"},"5.1.1 Source File Element Header"),Object(r.b)("p",null,"Guideline: Prefix each source file with a template header."),Object(r.b)("p",null,"The following information shall be provided as a minimum in the source\nfile header:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Copyright statement",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"Copyright information to protect the business from infringement"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"File name",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The source file name, fully qualified if deemed necessary"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Revision",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The revision of the file as determined by a version control system"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Author",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The name or ID of the person who created the file."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Date",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The date the file was last changed, in ISO 8601 if possible (e.g.\nYYYYMMDD HH:MM), or any other unambiguous format (e.g., 24-May-2012,\nMay 24, 2012). Formats such as 04/05/2012 shall not be used due to\nthe ambiguity (4 May or 5 April?)."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Element interface",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"This describes the objects exported by the file, or imported into\nit."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Description",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"A description of the what the file does.")))),Object(r.b)("p",null,"A conforming format is shown below. It assumes no tool support. But if a\ntool can insert relevant data, then it should do so; however, if use of\nsuch a tool means the format below cannot be adhered to, these\nGuidelines permit a format as close as possible to that below."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/*\n************************************************************************\n************************************************************************\nCOPYRIGHT GLASSWALL SOLUTIONS LIMITED 2012\nFILE NAME: initialise.c\nREVISION: 1.9\nAUTHOR: GPerkins\nDATE: 2011-10-02 09:23\n       INTERFACE:\n           FUNCTIONS: set_msg_out\n                      syntax_find\n            SCALARS: status\n                     bufsize\n                     arr\n    DESCRIPTION\n    Performs system-wide initialisation following system load. The\n    scheduler must be inactive before syntax_find is invoked.\n------------------------------------------------------------------------\n*/\n")),Object(r.b)("h4",{id:"512-header-file-element-header"},"5.1.2 Header File Element Header"),Object(r.b)("p",null,"Guideline: Prefix each header file with a template header."),Object(r.b)("p",null,"The following information shall be provided as commentary in the source\nfile header:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Copyright statement",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"Copyright information to protect the business from infringement"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"File name",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The source file name, fully qualified if deemed necessary"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Revision",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The revision of the file as determined by a version control system"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Author",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The name or ID of the person who created the file."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Date",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"The date the file was last changed, in ISO 8601 if possible (e.g.\nYYYYMMDD HH:MM), or any other unambiguous format (e.g., 24-May-2012,\nMay 24, 2012). Formats such as 04/05/2012 shall not be used due to\nthe ambiguity (4 May or 5 April?)."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Element interface",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"This describes the objects exported by the file, or imported into\nit."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Description",Object(r.b)("br",null),"\n",Object(r.b)("em",{parentName:"p"},"A description of the what the file does.")))),Object(r.b)("p",null,"A conforming format is shown below. It assumes no tool support. But if a\ntool can insert relevant data, then it should do so; however, if use of\nsuch a tool means the format below cannot be adhered to, these\nGuidelines permit a format as close as possible to that below."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/*\n************************************************************************\n************************************************************************\nCOPYRIGHT GLASSWALL SOLUTIONS LIMITED 2012\nlitdef.h\n        INTERFACE:\n            FUNCTIONS: set_msg_out\n                       syntax_find\n            SCALARS: status\n                     bufsize\n                     arr\n        DESCRIPTION\n        Macro definitions for global use.\n------------------------------------------------------------------------\n*/\n")),Object(r.b)("h3",{id:"52-unit-header"},"5.2 Unit Header"),Object(r.b)("p",null,"Guideline: Prefix each unit with a template header."),Object(r.b)("p",null,"Units, in C terminology, are functions."),Object(r.b)("p",null,"A unit header shall be provided for each C function. The unit name,\ndescription, and parameters shall be included in the header. ",Object(r.b)("inlineCode",{parentName:"p"},"RETURNS")," and\n",Object(r.b)("inlineCode",{parentName:"p"},"EXTERNAL VARIABLES CHANGED")," need to be present only if relevant to that\nunit."),Object(r.b)("p",null,"A conforming format is shown below. It assumes no tool support. But if a\ntool can insert relevant data, then it should do so; however, if use of\nsuch a tool means the format below cannot be adhered to, these\nGuidelines permit a format as close as possible to that below."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/*\n************************************************************************\n************************************************************************\nFUNCTION: set_msg_out\n\nDESCRIPTION: Places a message in a buffer. The message can have several meanings:\n                nop -- no message\n                reject -- message received is rejected\n                msg_par_err -- message parity error\n                abort -- fatal error, abort comms session\n\nPARAMETERS: msg -- the response we are placing in the output buffer\n\nRETURNS: MSG_OVERFLOW indicating buffer overflow, or SUCCESS\nindicating successful execution.\n------------------------------------------------------------------------\n*/\nStatus set_msg_out(unsigned char *msg)\n{\n    . . .\n} /* set_msg_out */\n")),Object(r.b)("h2",{id:"6-code-layout"},"6 CODE LAYOUT"),Object(r.b)("h3",{id:"61-module-layout"},"6.1 Module Layout"),Object(r.b)("p",null,"Guideline: Where present, sections of code should be laid out in the\nfollowing order, prefixed by the comment shown."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* includes */\n")),Object(r.b)("p",null,"One or more ","#","include directives."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* defines */\n")),Object(r.b)("p",null,"One or more ","#","define directives."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* typedefs */\n")),Object(r.b)("p",null,"One or more typedef statements, one per line."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* globals */\n")),Object(r.b)("p",null,"One or more C declarations, one per line; intended to be visible outside\nthe module."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* forward declarations */\n")),Object(r.b)("p",null,"One or more ANSI C function prototypes, one per line; must apply only to\nlocal functions (others should be in a header file)."),Object(r.b)("h3",{id:"62-bracketing"},"6.2 Bracketing"),Object(r.b)("p",null,"Guideline: Brace and parenthesize using BSD and GNU style."),Object(r.b)("p",null,"When setting out a code block, use the BSD and GNU style of bracketing.\nThat is, place the opening brace on a separate line by itself, indented\nto the same level as the controlling expression. Place the closing brace\non a separate line, at the same indentation level."),Object(r.b)("p",null,"Use the same formatting for bracketed lists over multiple lines, for example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'static char *name[] =\n{\n    "Illegal month",\n    "January", "February", "March",\n    "April",   "May",      "June",\n    "July",    "August",   "September",\n    "October", "November", "December"\n};\n')),Object(r.b)("h3",{id:"63-keywords"},"6.3 Keywords"),Object(r.b)("p",null,"Guideline: Separate your control keywords from the following opening bracket."),Object(r.b)("p",null,"Control structures regulate the dynamic behaviour of a program, so the\nkeywords of control structures are amongst the most critical components\nof a program. It's important those keywords stand out clearly in the\nsource code and are distinguished from function calls."),Object(r.b)("p",null,"To achieve this distinction, place a single space between a keyword and\nthe following bracket:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* CONFORMANT */\nfor (i=0; i < NELEMENTS(name_array); ++i)\n    ...\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nfor(i=0; i < NELEMENTS(name_array); ++i)\n    ...\n")),Object(r.b)("h3",{id:"64-subroutines-and-variables"},"6.4 Subroutines and Variables"),Object(r.b)("p",null,"Guideline: Don't separate subroutine or variable names from the following opening bracket."),Object(r.b)("p",null,"Function or variable names shall be followed by an opening parenthesis\nwithout any intervening spaces. This ensures that a function call is not\nmistaken for a control structure."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* CONFORMANT */\ninitialise();\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\ninitialise ();\n")),Object(r.b)("h3",{id:"65-line-lengths"},"6.5 Line Lengths"),Object(r.b)("p",null,"Guideline: Use 78-column lines."),Object(r.b)("p",null,"These guidelines recommend that code be constrained to a width that\nsupports adherence to other guidelines in this document."),Object(r.b)("p",null,"See also \xa7",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#610-vertical-alignment"}),"\xa76.10")," \u2014 6.13."),Object(r.b)("h3",{id:"66-indentation"},"6.6 Indentation"),Object(r.b)("p",null,"Guideline: Use four-column indentation levels."),Object(r.b)("p",null,"In experiments to measure the effectiveness of indentation as an aid to\nprogram understanding, it was discovered that an indentation level\nbetween 2 and 4 was most effective. Smaller and larger values were found\nto be detrimental to the understandability of the program."),Object(r.b)("p",null,"These guidelines mandate an indentation level of four columns."),Object(r.b)("h3",{id:"67-tabs"},"6.7 Tabs"),Object(r.b)("p",null,"Guideline: Indent with spaces, not tabs."),Object(r.b)("p",null,"Tabs do not appear the same when printed on different output devices, or\npasted into word processor documents, viewed on someone else's tabspaced\neditor, or prefixed with line numbers for code reviews or peer reviews."),Object(r.b)("p",null,"Do not use tabs alone, or, even worse, intermixed with spaces."),Object(r.b)("p",null,"Use spaces to ensure that indentation remains reliable, repeatable, and\ntransportable across viewing environments."),Object(r.b)("p",null,"Note that this does not mean you cannot use the Tab key in your code\neditor. Most editors have a setting that will insert spaces when the Tab\nkey is pressed. These Guidelines mandates that such editors are set to\ninsert four spaces and not the tab character."),Object(r.b)("h3",{id:"68-blocks"},"6.8 Blocks"),Object(r.b)("p",null,"Guideline: Never place two statements on one line."),Object(r.b)("p",null,"If two or more statements are placed on one line, each of them becomes harder to comprehend."),Object(r.b)("h3",{id:"69-chunking"},"6.9 Chunking"),Object(r.b)("p",null,"Guideline: Code in paragraphs."),Object(r.b)("p",null,"Break the code into sequences that achieve a single task, with a single\nempty line between each sequence."),Object(r.b)("p",null,"Precede each sequence with a comment to further improve the\nmaintainability of the code. These comments need to explain why the code\nis needed, not merely paraphrase what it's doing."),Object(r.b)("h3",{id:"610-vertical-alignment"},"6.10 Vertical Alignment"),Object(r.b)("p",null,"Guideline: Corresponding items shall be aligned vertically."),Object(r.b)("p",null,"It's often useful to align data in a table-like series of columns.\nConsistent indentation can suggest equivalences in structure, usage, or\npurpose."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* FEB = 2, MAR = 3, etc. */\nenum months\n{\n    JAN = 1, FEB, MAR,\n    APR,     MAY, JUN,\n    JUL,     AUG, SEP,\n    OCT,     NOV, DEC\n};\n")),Object(r.b)("p",null,"Sequences of related variables shall be tabulated similarly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"name   = standardise_name(name);\nage    = get_now_time() - birth_date;\nstatus = active;\n")),Object(r.b)("h3",{id:"611-breaking-long-lines"},"6.11 Breaking Long Lines"),Object(r.b)("p",null,"Guideline: Break long expressions before an operator."),Object(r.b)("p",null,"Although it is common practice to break an expression after an operator\nand continue the expression on the following line, indented by one level\n(the idea being the operator acts as a continuation marker) there is a\nproblem: people rarely look at the right edge of code. Most semantic\nhints such as keywords, appear on the left. Breaking the line ",Object(r.b)("em",{parentName:"p"},"before"),"\nan operator is a cleaner solution. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* CONFORMANT */\nstep = step\n       + radial_velocity * elapsed_time\n       + orbital_velocity * (phase + phase_shift)\n       - DRAG_COEFF * altitude\n       ;\n")),Object(r.b)("p",null,"The semicolon on its own indented to the same column as the continued\nexpression informs the reader the expression is complete, as he or she\nscans down the leading operators."),Object(r.b)("p",null,"Continued lines should not be simply indented to the next indentation\nlevel, they should be indented to the starting column of the expression\nto which they belong."),Object(r.b)("p",null,"So don't do this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON_CONFORMANT */\nstep = step\n           + radial_velocity * elapsed_time\n           + orbital_velocity * (phase + phase_shift)\n           - DRAG_COEFF * altitude\n           ;\n")),Object(r.b)("h3",{id:"612-breaking-by-precedence"},"6.12 Breaking by Precedence"),Object(r.b)("p",null,"Guideline: Always break a long expression at the operator of the lowest possible precedence."),Object(r.b)("p",null,"The example in 6.11 shows that when breaking an expression across\nseveral lines, each line should be broken before a low-precedence\noperator. Breaking at higher precedence will encourage an unwary reader\nto misunderstand the computation. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nstep = step + radial_velocity\n            * elapsed_time + orbital_velocity\n            * (phase + phase_shift) - DRAG_COEFF\n            * altitude\n            ;\n")),Object(r.b)("p",null,"This suggests that additions and subtractions happen before the multiplication."),Object(r.b)("p",null,"If you need to break on an operator of less-than-minimal precedence,\nindent the broken line one additional level relative to the start of the\nexpression, like so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* CONFORMANT */\nstep = step\n       + radial_velocity * elapsed_time\n       + orbital_velocity\n           * (phase + phase_shift)\n       - DRAG_COEFF * altitude\n       ;\n")),Object(r.b)("h3",{id:"613-assignments"},"6.13 Assignments"),Object(r.b)("p",null,"Guideline: Break long assignments before the assignment operator."),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"predicted_val\n    = average + predicted_change * fudge_factor;\n")),Object(r.b)("p",null,"If the righthand side of the assignment won't fit on one line, break it\nagain at a low-precedence operator, as suggested in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#612-breaking-by-precedence"}),"Para. 6.12"),"."),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"predicted_val\n    = (minimum + maximum) / 2\n         + predicted_change * max(fudge_factor, local_epsilon);\n")),Object(r.b)("h3",{id:"614-automated-layout"},"6.14 Automated Layout"),Object(r.b)("p",null,"Guideline: Enforce your chosen layout style automatically."),Object(r.b)("p",null,"In the long term, the coding team should be trained to code in a\nconsistent, rational, and readable style. Time and commitment to\naccomplish this isn't always available. A reasonable compromise is to\nprescribe a standard code-formatting tool that must be applied to all\ncode before it's committed, reviewed, or otherwise displayed in public."),Object(r.b)("h2",{id:"7-c-implementation"},"7 C IMPLEMENTATION"),Object(r.b)("h3",{id:"71-header-files"},"7.1 Header Files"),Object(r.b)("p",null,"Guideline: Ensure header files are idempotent."),Object(r.b)("p",null,"Use a macro guard in header files to implement idempotence:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* FILE: header.h */\n#ifndef HEADER_H\n#define HEADER_H\n... /* body of .h file */\n#endif\n")),Object(r.b)("p",null,"The macro name should be the name of the file with all full stops,\nnon-alphabetic, and non-digit characters replaced by underscores. Never begin\na macro name with an underscore character."),Object(r.b)("h3",{id:"72-header-file-content"},"7.2 Header File Content"),Object(r.b)("p",null,"Guideline: Do not define functions or objects in header files."),Object(r.b)("p",null,"Header file content should fall into roughly three types:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"External declarations and function prototypes"),Object(r.b)("li",{parentName:"ul"},"Structure definitions, and structure ",Object(r.b)("inlineCode",{parentName:"li"},"typedef")," declarations"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"#define"),"d preprocessor directives for global use, and ",Object(r.b)("inlineCode",{parentName:"li"},"typedef"),"\ndeclarations for non-structure types")),Object(r.b)("p",null,"Functions or objects should not be defined in a header file."),Object(r.b)("p",null,"Reference: MISRA-C:2004 Rule 8.5."),Object(r.b)("h3",{id:"73-goto"},"7.3 Goto"),Object(r.b)("p",null,"Guideline: Do not use the ",Object(r.b)("inlineCode",{parentName:"p"},"goto")," statement."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"goto")," is never necessary, and in practice it is almost always easy to\nwrite code without it."),Object(r.b)("p",null,"References: Ref 7 Rule 14.4."),Object(r.b)("h3",{id:"74-functions"},"7.4 Functions"),Object(r.b)("p",null,"There are several guidelines for function."),Object(r.b)("p",null,"7.4.1 Functions should be as short as practicable. Excluding the unit header, a function should span at most two screens."),Object(r.b)("p",null,"7.4.2 The function name shall be unique and describe its purpose. See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#8.1.3.2"}),"Para. 8.1.3.2"),"."),Object(r.b)("p",null,"7.4.3 Use the type-qualifier ",Object(r.b)("inlineCode",{parentName:"p"},"const")," for function parameters to indicate that the function does not change those values. Do this in both the definitions and the declarations. This does not apply to scalar parameters."),Object(r.b)("p",null,"7.4.4 The brace ",Object(r.b)("inlineCode",{parentName:"p"},"}")," which terminates the block that provides the code for a function shall be followed by a comment of the form:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* End of function function-name */\n")),Object(r.b)("p",null,"and shall appear on the same line as that block delimiter."),Object(r.b)("p",null,"7.4.5 All function names within a separately compiled group of elements should be prefixed with a short mnemonic. For example, ",Object(r.b)("inlineCode",{parentName:"p"},"hdc_")," (to denote hard disc controller), particularly when more than one task is present on the system."),Object(r.b)("h3",{id:"75-null-pointers"},"7.5 Null Pointers"),Object(r.b)("p",null,"For each pointer type, C defines a special pointer value, the null\npointer, that is guaranteed not to point to any object or function of\nthat type. The ",Object(r.b)("em",{parentName:"p"},"null pointer constant")," used for representing null\npointers in source code involves the integer 0, and many machines\nrepresent null pointers internally as a word with all bits zero, but the\nsecond fact is ",Object(r.b)("em",{parentName:"p"},"not")," guaranteed by the language."),Object(r.b)("h4",{id:"751-the-null-macro"},"7.5.1 The NULL Macro"),Object(r.b)("p",null,"Guideline: Use the ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," macro instead of 0 in pointer contexts."),Object(r.b)("p",null,"So that a program's use of null pointers can be made more explicit, a\nstandard pre-processor macro, ",Object(r.b)("inlineCode",{parentName:"p"},"NULL"),", is defined, having as its value a\nnull pointer constant. Using the macro instead of an unadorned 0 in\npointer contexts indicates a special value for a pointer is being used."),Object(r.b)("p",null,"References: K&R2 \xa75.4 p. 102"),Object(r.b)("h4",{id:"752-pointer-arguments"},"7.5.2 Pointer Arguments"),Object(r.b)("p",null,"Guideline: A null pointer shall be cast to its correct type when used as\nan argument to a function call."),Object(r.b)("p",null,'According to the language definition, an "integral constant expression\nwith the value 0" in a pointer context is converted into a null pointer\nat compile time, and will generate the correctly typed null pointer\nvalue. This applies when using the ',Object(r.b)("inlineCode",{parentName:"p"},"NULL")," macro as well. So the following\nare perfectly legal:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"char *p = NULL;\nif (p != NULL)\n")),Object(r.b)("p",null,"However, an argument passed to a function is not necessarily\nrecognisable as a pointer context, and the compiler may not recognise an\nunadorned 0 (or the ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," macro) as a null pointer. In this case, an\nexplicit cast may be required. For example, the UNIX system call ",Object(r.b)("inlineCode",{parentName:"p"},"execl"),"\ntakes a variable-length, null pointer-terminated list of character\npointer arguments and is correctly called like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'execl("/bin/sh", "sh", "-c", "date", (char *)NULL);\n')),Object(r.b)("p",null,"Without the ",Object(r.b)("inlineCode",{parentName:"p"},"(char\xa0*)")," cast on the last argument, the compiler would not\nknow to pass a null pointer and would pass an integer 0 instead."),Object(r.b)("p",null,'When a function prototype is in scope, argument passing becomes an\n"assignment context" and most casts may be safely omitted.'),Object(r.b)("p",null,"Function prototypes cannot provide the types for variable arguments in\nvariable-length argument lists, so casts are still required."),Object(r.b)("p",null,"As explained above, although null pointer casts of function arguments\nare necessary only where there is no prototype in scope, or when passed\nas a variable argument in a varargs function call, it is safest to\nproperly cast all null pointers in function calls."),Object(r.b)("p",null,"References: K&R2 \xa77.10 p. 207, \xa7A7.17 p. 209; ANSI \xa73.2.2.3; ISO\n\xa76.2.2.3"),Object(r.b)("h4",{id:"753-function-pointers"},"7.5.3 Function Pointers"),Object(r.b)("p",null,"Guideline: A function pointer shall not be converted to type void\xa0","*","."),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"void\xa0*")," is guaranteed to hold only object (i.e., data) pointers;\nconverting a function pointer to type ",Object(r.b)("inlineCode",{parentName:"p"},"void\xa0*")," is not portable."),Object(r.b)("p",null,"It is guaranteed, however, that all function pointers can be\ninterconverted, as long as they are converted back to an appropriate\ntype before calling. Therefore, you can pick any function type as a\ngeneric function pointer (usually ",Object(r.b)("inlineCode",{parentName:"p"},"int\xa0(*)()")," or ",Object(r.b)("inlineCode",{parentName:"p"},"void\xa0(*)()"),")."),Object(r.b)("p",null,"References: ANSI \xa73.1.2.5, \xa73.2.2.3, 3.3.4; ISO \xa76.1.2.5, \xa76.2.2.3,\n\xa76.3.4"),Object(r.b)("h3",{id:"76-preprocessor"},"7.6 Preprocessor"),Object(r.b)("p",null,"7.6.1 Guideline: In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of ",Object(r.b)("inlineCode",{parentName:"p"},"#")," or ",Object(r.b)("inlineCode",{parentName:"p"},"##"),"."),Object(r.b)("p",null,"Using parentheses protects any low-precedence operators in the actual\narguments from the rest of the macro expansion."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 19.10."),Object(r.b)("p",null,"7.6.2 Guideline: C macros shall expand only to a braced initialiser, a constant, a parenthesised expression, a type qualifier, a storage class specifier, or a do-while-zero construct."),Object(r.b)("p",null,"Any other use of ",Object(r.b)("inlineCode",{parentName:"p"},"#define")," could lead to unexpected behaviour or\nhard-to-read code."),Object(r.b)("p",null,"For complete statements in a macro body, the do-while-zero construct is\nthe only permitted mechanism. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#define READ_TIME_32() \\\ndo \\\n{ \\\n    DISABLE_INTERRUPTS(); \\\n    time_now = (uint32_t)TIMER_HI << 16; \\\n    time_now = time_now | (uint32_t)TIMER_LO; \\\n    ENABLE-INTERRUPTS(); \\\n} while (0)\n")),Object(r.b)("p",null,"Note that the semicolon ",Object(r.b)("em",{parentName:"p"},"must")," be omitted from the end of the macro body."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 19.4."),Object(r.b)("h3",{id:"77-booleans"},"7.7 Booleans"),Object(r.b)("p",null,"7.7.1 ",Object(r.b)("a",{name:"7.7.1"})," Defining TRUE and FALSE\nGuideline: Define pre-processor macros or enumeration constants for true\nand false values, which evaluate to 1 and 0."),Object(r.b)("p",null,"The choice between ",Object(r.b)("inlineCode",{parentName:"p"},"#defines")," and enumeration constants for the true and\nfalse values is arbitrary, but consistency shall be maintained within a\nprogram or project. Use any of:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#define TRUE 1\n#define FALSE 0\n")),Object(r.b)("p",null,"or"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"enum Bool {FALSE, TRUE};\n")),Object(r.b)("p",null,"or"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"typedef enum {FALSE, TRUE} Bool;\n")),Object(r.b)("p",null,"And also:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"typedef int Bool;\n")),Object(r.b)("p",null,"or"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"typedef char Bool;\n")),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#772-use-of-true-and-false"}),"\xa77.7.2"),"; ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#82-booleans"}),"\xa78.2"),"."),Object(r.b)("h4",{id:"772-use-of-true-and-false"},"7.7.2 Use of TRUE and FALSE"),Object(r.b)("p",null,"Guideline: Only assign TRUE and FALSE to a Boolean variable, never use\nthem in comparisons."),Object(r.b)("p",null,'Even though any nonzero value is considered true in C, this only applies\n"on input", i.e., where a Boolean value is expected. When a Boolean\nvalue is generated by a built-in operator, such as ',Object(r.b)("inlineCode",{parentName:"p"},"=="),", ",Object(r.b)("inlineCode",{parentName:"p"},"!="),", and ",Object(r.b)("inlineCode",{parentName:"p"},"<="),", it\nis guaranteed to be 1 or 0. Therefore, a test like"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nif ((a==b) == TRUE)\n")),Object(r.b)("p",null,"would work as expected, but is pointless. Generally, explicit tests\nagainst TRUE and FALSE are inappropriate, and, unlike the built-in\noperators, some library functions (notably ",Object(r.b)("inlineCode",{parentName:"p"},"isupper"),", ",Object(r.b)("inlineCode",{parentName:"p"},"isalpha"),", etc.)\nreturn, on success, a nonzero value that is ",Object(r.b)("em",{parentName:"p"},"not")," necessarily 1, so\ncomparing their return values against a single value, such as TRUE, is\nrisky and likely not to work. The above should be written:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (a==b)\n")),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#7.7.1"}),"\xa77.7.1"),"; ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#82-booleans"}),"\xa78.2"),"."),Object(r.b)("h3",{id:"78-pointer-declarations"},"7.8 Pointer Declarations"),Object(r.b)("p",null,"Guideline: When declaring or defining a pointer variable, always ensure\nthere is no whitespace between the ",Object(r.b)("inlineCode",{parentName:"p"},"*")," and the identifier."),Object(r.b)("p",null,"C's declarations come in two parts: a base type and a ",Object(r.b)("em",{parentName:"p"},"declarator"),". The\ndeclarator may also contain the characters ",Object(r.b)("inlineCode",{parentName:"p"},"*"),", ",Object(r.b)("inlineCode",{parentName:"p"},"[]"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"()"),", saying\nwhether the name is a pointer to, array of, or function returning the\nbase type, or some combination."),Object(r.b)("p",null,"In"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"char *pc;\n")),Object(r.b)("p",null,"the base type is ",Object(r.b)("inlineCode",{parentName:"p"},"char"),", the identifier is ",Object(r.b)("inlineCode",{parentName:"p"},"pc"),", and the declarator is ",Object(r.b)("inlineCode",{parentName:"p"},"*pc"),";\nthis tells us that ",Object(r.b)("inlineCode",{parentName:"p"},"*pc")," is a ",Object(r.b)("inlineCode",{parentName:"p"},"char"),'. The syntax of the declaration for a\nvariable mimics the syntax of expressions in which the variable might\nappear and is what "declaration mimics use" means.'),Object(r.b)("p",null,"If we write:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nchar* p1, p2;\nchar * p3, p4;\n")),Object(r.b)("p",null,"only one pointer variable is being declared, on each line, despite what\nthe whitespace might suggest. Both forms invite mistakes and are\nconfusing."),Object(r.b)("p",null,"The correct way to declare them would clearly show that only ",Object(r.b)("inlineCode",{parentName:"p"},"p1")," and ",Object(r.b)("inlineCode",{parentName:"p"},"p3"),"\nare pointers:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"char *p1, p2;\nchar *p3, p4;\n")),Object(r.b)("p",null,"References: Ref 2, \xa75.1; Ref 6 Q1.5, Q1.21."),Object(r.b)("h2",{id:"8-naming-conventions"},"8 NAMING CONVENTIONS"),Object(r.b)("p",null,"Guideline: Name all objects."),Object(r.b)("p",null,"It is possible to create an enumeration without specifying an identifier:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"enum {NAME, PARENS, BRACKETS};\n\n/* and later */\nint token_type;\n. . .\ntoken_type = PARENS;\n")),Object(r.b)("p",null,"But it is clearer to name it and declare any object that will hold its values of that type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"enum tokens {NAME, PARENS, BRACKETS\\];\n\n/* later */\nenum tokens token_type;\n. . .\ntoken_type = PARENS;\n")),Object(r.b)("p",null,"Compilers need not check that what is stored in such a variable is a\nvalid value for the enumeration, but they offer the chance of checking\nand in many cases are better than ",Object(r.b)("inlineCode",{parentName:"p"},"#define"),"s. Also, a debugger may be\nable to print values of enumeration variables in their symbolic form. It\nis also clear from the code what the author intended."),Object(r.b)("p",null,"It would also be clearer to declare the type using ",Object(r.b)("inlineCode",{parentName:"p"},"typedef"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"typedef enum {NAME, PARENS, BRACKETS} Token_type;\nToken_type token_type;\n")),Object(r.b)("p",null,"References: Ref 2 \xa72.3, \xa7A.8.4"),Object(r.b)("p",null,"In the rules below, ",Object(r.b)("inlineCode",{parentName:"p"},"*")," means zero or more repetitions of the preceding\nitem, and ",Object(r.b)("inlineCode",{parentName:"p"},"?")," means 0 or 1 instances."),Object(r.b)("h3",{id:"81-identifiers"},"8.1 Identifiers"),Object(r.b)("p",null,'8.1.1 Guideline: No identifier shall begin with an underscore.\nThe reason for this guideline is to prevent creating an identifier that\nis already in use by the implementation. If you begin an identifier with\nan underscore, at best, you will get "multiply defined" errors. At\nworst, it will quietly replace one of the implementation\'s symbols and\nbreak everything.'),Object(r.b)("p",null,"It is possible to break this Guideline and use identifiers with\nunderscores safely within certain namespaces, but the rules are complex\nand it is simpler &emdash; and safer &emdash; simply not to use an underscore as\nthe first character of any identifier."),Object(r.b)("p",null,"References: Ref 6, Q1.29 p. 23; ISO \xa77.1.3."),Object(r.b)("p",null,"8.1.2  Guideline: Identifiers (internal and external) and pre-processor macro names shall not rely on the significance of more than 31 characters."),Object(r.b)("p",null,"Although some implementations may make at least the first 31 characters\nof internal identifiers significant, it is safer to restrict all\nidentifiers (including pre-processor macro names) to a maximum of 31\ncharacters."),Object(r.b)("p",null,"Reference: Ref 7 Rule 5.1; Ref 2 \xa7A.2.3."),Object(r.b)("p",null,"8.1.3 Guideline: Use grammatical templates when forming identifiers and function names."),Object(r.b)("p",null,"8.1.3.1 Variables"),Object(r.b)("p",null,"Variables should be named according to the values they will store and as\nspecifically as possible."),Object(r.b)("p",null,"The recommended grammar rule is very simple:"),Object(r.b)("p",null,"\xa0","\xa0","\xa0","\xa0",Object(r.b)("em",{parentName:"p"},"variable")," \u2192 ","[",Object(r.b)("em",{parentName:"p"},"adjective")," _ ","]","*"," ",Object(r.b)("em",{parentName:"p"},"noun")),Object(r.b)("p",null,"The choice of nouns and adjectives is critical. The nouns in particular\nshould indicate what the variable does in terms of the problem domain,\nnot in terms of the implementation. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"next_client           /* not: next_elem */\nprev_appointment      /* not: prev_elem */\nestimated_net_worth   /* not: value */\nnext_node             /* not: node */\nroot_node             /* not: root */\nfinal_total           /* not: sum */\ncumulative_total      /* not: partial_sum */\n")),Object(r.b)("p",null,"Note, however, it is often acceptable to name parameters in short, tight\nfunctions, using the normal C idioms:"),Object(r.b)("p",null,"\xa0","\xa0","\xa0","\xa0",Object(r.b)("inlineCode",{parentName:"p"},"s")," to denote a string",Object(r.b)("br",null),"\n","\xa0","\xa0","\xa0","\xa0",Object(r.b)("inlineCode",{parentName:"p"},"c")," to denote a ",Object(r.b)("inlineCode",{parentName:"p"},"char"),Object(r.b)("br",null),"\n","\xa0","\xa0","\xa0","\xa0",Object(r.b)("inlineCode",{parentName:"p"},"i")," to denote a loop index",Object(r.b)("br",null)),Object(r.b)("p",null,"8.1.3.2 ",Object(r.b)("a",{name:"8.1.3.2"})," Functions\nA suitable grammatical rule for forming function names is:"),Object(r.b)("p",null,"\xa0","\xa0","\xa0","\xa0",Object(r.b)("em",{parentName:"p"},"function")," \u2192 ",Object(r.b)("em",{parentName:"p"},"imperative_verb")," ","["," ","_"," ",Object(r.b)("em",{parentName:"p"},"adjective"),"]","? ","_"," ",Object(r.b)("em",{parentName:"p"},"noun")," ","_"," ",Object(r.b)("em",{parentName:"p"},"preposition"),Object(r.b)("br",null),"\n","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","| ",Object(r.b)("em",{parentName:"p"},"imperative_verb")," ","["," ","_"," ",Object(r.b)("em",{parentName:"p"},"adjective"),"]","? ","_"," ",Object(r.b)("em",{parentName:"p"},"noun")," ","_"," ",Object(r.b)("em",{parentName:"p"},"participle"),Object(r.b)("br",null),"\n","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","\xa0","| ",Object(r.b)("em",{parentName:"p"},"imperative_verb")," ","["," ","_"," ",Object(r.b)("em",{parentName:"p"},"adjective"),"]","? ","_"," ",Object(r.b)("em",{parentName:"p"},"noun")),Object(r.b)("p",null,"This will give function names such as:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"get_record                      /* imperative_verb noun */\nget_record_for                  /* imperative_verb noun preposition */\neat_cookie                      /* imperative_verb noun */\neat_previous_cookie             /* imperative_verb adjective noun */\nbuild_profile                   /* imperative_verb noun */\nbuild_execution_profile         /* imperative_verb adjective noun */\nbuild_execution_profile_using   /* imperative_verb adjective noun */\n")),Object(r.b)("p",null,"The reason for prepositions is that they can create variables that read\nfar more naturally and can eliminate the need for additional comments:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"config_options = get_record_for(next_client);\n\nbuild_execution_profile_using(next_client, option);\n")),Object(r.b)("h3",{id:"82-booleans"},"8.2 Booleans"),Object(r.b)("p",null,"Guideline: Name Booleans after their associated test."),Object(r.b)("p",null,"Booleans should be named for the properties or predicates they test, in\nsuch a way that the resulting conditional expression reads naturally.\nThis means they will usually begin with ",Object(r.b)("inlineCode",{parentName:"p"},"is_")," or ",Object(r.b)("inlineCode",{parentName:"p"},"has_"),", but not always.\nFor example, consider this code fragment:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (is_valid(next_record) && !loading_finished)\n{\n    while (metadata_available_for(next_record))\n    {\n        push(metadata, get_metadata_for(next_record));\n        if (has_end_tag(next_record)\n        break;\n    }\n}\nelse\n{\n    has_found_bad_record = TRUE;\n}\n")),Object(r.b)("p",null,"Note how the use of carefully constructed identifiers, and function\nnames eliminates the need for comments."),Object(r.b)("h3",{id:"83-pointer-variables"},"8.3 Pointer Variables"),Object(r.b)("p",null,"Guideline: Mark variables that store pointers."),Object(r.b)("p",null,"To obviate using a pointer variable in a context when it should be\ndereferenced, and deferencing a pointer when it shouldn't be, either\nsuffix the variable name with ",Object(r.b)("inlineCode",{parentName:"p"},"_p"),", prefix it with ",Object(r.b)("inlineCode",{parentName:"p"},"p"),", or provide some\nother indication that it is a pointer."),Object(r.b)("p",null,"By conforming to this guideline, you can ensure a coder understands that\nhe or she is dealing with a pointer. This coding practice would make it\nclear that it is likely a ",Object(r.b)("inlineCode",{parentName:"p"},"*")," should appear before a variable named in\nsuch a way:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* CONFORMANT */\n/* calculate how much wider than text the width (columns) is */\ngap = *p_col_opt - strlen(text);\n")),Object(r.b)("p",null,"and this would look suspicious:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\ngap = p_col_opt - strlen(text);\n")),Object(r.b)("h3",{id:"84-arrays"},"8.4 Arrays"),Object(r.b)("p",null,"Guideline: Name arrays in the plural."),Object(r.b)("p",null,"Arrays are usually ordered sequences of multiple values, and are mostly\nprocessed collectively or iteratively, so it makes sense to name them in\nthe plural, after the group of items they store:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"char *filenames[FILENAMES_MAX] = {NULL}; /* initialise all to null pointer */\n\n/* And later... */\n\nfor (i = 0; i < NELEMENTS(filenames) && filenames[i] != NULL; ++i)\n{\n    puts(filenames[i]);\n}\n")),Object(r.b)("h3",{id:"85-multiword-identifiers"},"8.5 Multiword Identifiers"),Object(r.b)("p",null,"Guideline: Maintain consistency in the use of multiword identifiers."),Object(r.b)("p",null,"There are two main types of naming convention prevalent in naming\nvariables containing multi-words: Inter Caps and underscores."),Object(r.b)("p",null,"Underscores impose a visual gap between the words in an identifier, and\ntherefore are the closest to the default natural-language word\nseparator: the space."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"pdf_header_signature_inplace_str_token\n")),Object(r.b)("p",null,"On the other hand, use of Inter Caps is very common:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"pdfHeaderSignatureInplaceStrToken\n")),Object(r.b)("p",null,"Choose a style, and ensure it is used consistently throughout the code."),Object(r.b)("h3",{id:"86-abbreviations"},"8.6 Abbreviations"),Object(r.b)("p",null,"Guideline: Abbr idents by prefx."),Object(r.b)("p",null,"If you choose to abbreviate an identifier, abbreviate it by retaining\nthe start of each word. Compare these two code fragments:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"for (i = 0; i < NELEMENTS(orig_strs); ++i)\n{\n    len = strlen(orig_strs[i]);\n    if (len > UPPER_LIM)\n        continue;\n    max_len = MAX(max_len, len);\n}\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nfor (i = 0; i < NELEMENTS(rgnl_strgs); ++i)\n{\n    len = strlen(rgnl_strgs[i]);\n    if (lngh \\> UPPR_LMT)\n    continue;\n    max_lngh = MAX(max_lngh, lngh);\n}\n")),Object(r.b)("p",null,"When abbreviating identifiers, it is acceptable to keep the last\nconsonant (",Object(r.b)("inlineCode",{parentName:"p"},"orig_strs"),", ",Object(r.b)("inlineCode",{parentName:"p"},"prefx"),", ",Object(r.b)("em",{parentName:"p"},"etc."),"), especially if that consonant is a\nplural suffix."),Object(r.b)("p",null,'This rule need not apply to identifiers that are well-known standard\nabbreviations. In this case, it\'s better to use the "native"\nabbreviation strategy:'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"ctrl_char = ASCII_ESC; /* ASCII_ESC is a macro */\nconnection_Mbps = get_bitrate() / 1e6;\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Ctrl")," appears on most keyboards. ",Object(r.b)("inlineCode",{parentName:"p"},"Mbps")," is a standard unit."),Object(r.b)("h2",{id:"87-ambiguous-abbreviations"},"8.7 Ambiguous Abbreviations"),Object(r.b)("p",null,"Guideline: Abbreviate only when the meaning remains unambiguous."),Object(r.b)("p",null,"Abbreviation is a form of visual hashing, and can be useful in reducing\nthe length of identifiers, which then can be recognised as a single\nvisual chunk. Unfortunately, it can suffer from collisions."),Object(r.b)("p",null,"Some ambiguities are:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"temp       /* temporary or temperature? */\nterm_val   /* terminal value or termination valid? */\ndev        /* device or deviation? */\nno         /* number or no? */\n")),Object(r.b)("p",null,"There are exceptions. Abbreviating to a single character can be appropriate:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"a = f / m;\nv = u + a*t;\ns = u*t + 0.5*a*t*t;\n")),Object(r.b)("p",null,"Even single letter iterator variables - ",Object(r.b)("inlineCode",{parentName:"p"},"i"),", ",Object(r.b)("inlineCode",{parentName:"p"},"j"),", ",Object(r.b)("inlineCode",{parentName:"p"},"k"),", ",Object(r.b)("inlineCode",{parentName:"p"},"n"),", ",Object(r.b)("inlineCode",{parentName:"p"},"x"),", ",Object(r.b)("inlineCode",{parentName:"p"},"y"),", ",Object(r.b)("inlineCode",{parentName:"p"},"z")," - are\nacceptable in nested loops:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* squeeze.c: delete each char in s1 which is in s2 */\nvoid squeeze(char s1[], const char s2[])\n{\n    int i, j, k;\n\n    for (i = k = 0; s1[i] != '\\0'; i++)\n    {\n        for (j = 0; s2[j] != '\\0' && s2[j] != s1[i]; j++)\n            ;\n\n        if (s2[j] == '\\0') /* end of string - no match */\n            s1[k++] = s1[i];\n    }\n\n    s1[k] = '\\0';\n\n} /* squeeze */\n")),Object(r.b)("h3",{id:"88-ambiguous-names"},"8.8 Ambiguous Names"),Object(r.b)("p",null,"Guideline: Avoid using inherently ambiguous words in names."),Object(r.b)("p",null,"Abbreviations are not the only cause of ambiguities in identifiers. Some\ncomplete words have one or more homonyms."),Object(r.b)("p",null,'One of the worst offenders in this regard is "last".'),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"last_record")," might mean the record that was most recently processed (call\nit ",Object(r.b)("inlineCode",{parentName:"p"},"prev_record"),"), or to the ultimate record in a list (call it\n",Object(r.b)("inlineCode",{parentName:"p"},"final_record"),")."),Object(r.b)("p",null,'"set" is another problem. ',Object(r.b)("inlineCode",{parentName:"p"},"get_set()")," could mean get a collection of\nvalues (call it ",Object(r.b)("inlineCode",{parentName:"p"},"retrieve_collection()"),'), or it might test whether the\n"get" option has been enabled (call it ',Object(r.b)("inlineCode",{parentName:"p"},"get_is_enabled()"),"), or it might\nmediate both fetch and store operations of some value (call it\n",Object(r.b)("inlineCode",{parentName:"p"},"fetch_or_store()"),")."),Object(r.b)("p",null,"Avoid these words:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"left" (the direction ',Object(r.b)("em",{parentName:"p"},"vs")," what remains)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"right" (the other direction ',Object(r.b)("em",{parentName:"p"},"vs")," being correct vs an entitlement)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"no" (the negative ',Object(r.b)("em",{parentName:"p"},"vs")," the abbreviation for number)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"abstract" (theoretical ',Object(r.b)("em",{parentName:"p"},"vs")," pr\xe9cis ",Object(r.b)("em",{parentName:"p"},"vs")," to summarise)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"contract" (make smaller ',Object(r.b)("em",{parentName:"p"},"vs")," legal agreement)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"record" (an extreme outcome ',Object(r.b)("em",{parentName:"p"},"vs")," a data aggregation vs to log)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"second" (the ordinal position ',Object(r.b)("em",{parentName:"p"},"vs")," the unit of time)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"close" (near ',Object(r.b)("em",{parentName:"p"},"vs")," to shut)")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},'"bases" (more than one base ',Object(r.b)("em",{parentName:"p"},"vs")," more than one basis)"))),Object(r.b)("h3",{id:"89-general-naming-conventions"},"8.9 General Naming Conventions"),Object(r.b)("p",null,"Guideline: Use K&R2 style use of case."),Object(r.b)("p",null,"The Kernighan & Ritchie convention is:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Convention"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"UPPERCASE_WITH_UNDERSCORE"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Macro names and enumeration constants")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Capitalised"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"typedef names")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"lowercase"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"other objects")))),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"typedef enum {FALSE,TRUE } Bool; /* Capitalised typedef, uppercase enum constants */\n#define LOWER 0                  /* A macro called LOWER */\nint fahr;                        /* An int variable called fahr */\n")),Object(r.b)("h2",{id:"9-documentation"},"9 DOCUMENTATION"),Object(r.b)("p",null,"This document has already described how unit and element headers should\nbe documented (See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#5"}),"Section 5"),"). This section describes guidelines for\ndocumenting the source code."),Object(r.b)("h3",{id:"91-algorithmic-documentation"},"9.1 Algorithmic Documentation"),Object(r.b)("p",null,"Guideline: Use full-line comments to explain the algorithm."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#69-chunking"}),"Para. 6.9")," mentions coding in paragraphs, including advice on prefixing\neach paragraph with a single-line comment which explains at high level\nwhat the associated paragraph contributes to the overall process\nimplemented by the code. If all the paragraph comments were to be\nextracted, they should summarise the algorithm by which the code\nperforms its task. Indeed, the use of a tool to perform such processing\nis recommended."),Object(r.b)("p",null,"Keep each such comment strictly to a single line. Any more than that\ninterrupts the code excessively, making it harder to follow. If the\nparagraph is doing something too complicated to be explained in a single\nline, that is a sign that the code either needs to be split into several\nparagraphs, or else refactored out into a function (which can then be\ngiven a more expansive block comment)."),Object(r.b)("h3",{id:"92-elucidating-comments"},"9.2 Elucidating Comments"),Object(r.b)("p",null,"Guideline: Use end-of-line comments to point out subtleties and\noddities."),Object(r.b)("p",null,"The guidelines in this document should help you write code that is\nself-documenting, but such a thing is in the eye of the original author,\nand comprehensibility can suffer particularly badly when the code\nincorporates jargon from the problem domain. Terms that were extremely\nfamiliar to the original designers and implementers might mean nothing\nto those who later have to maintain the source. For example, you could\ninherit code like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-COMPLIANT */\nQFETM_Func_p QFETM_func_p;\nif (QFETM_func_p = get_GET( ))\n{\n    make_futtock(QFETM_func_p);\n}\n")),Object(r.b)("p",null,"In which case, trailing comments are appropriate:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"QFETM_Func_p QFETM_func_p; /* stores Quantum Field Effect Transfer Mode\nfunction */\n\n/* Build futtock representation if remote data are available . . . */\nif (QFETM_func_p = get_GET( ))           /* instead of get_POST( ) */\n{\n    make_futtock(QFETM_func_p); /* futtock: a rib of a ship's frame */\n}\n")),Object(r.b)("h3",{id:"93-defensive-documentation"},"9.3 Defensive Documentation"),Object(r.b)("p",null,"Guideline: Comment anything that has puzzled or tricked you."),Object(r.b)("p",null,'An in-line comment is appropriate whenever you encounter a subtle bug,\nor whenever you write some subtle code. "Subtle" has a very precise\ndefinition here: it means that you either had to look up something in a\nmanual, or had to spend more than five seconds thinking about it before\nyou understood its syntax or semantics.'),Object(r.b)("h3",{id:"94-indicative-documentation"},"9.4 Indicative Documentation"),Object(r.b)("p",null,"Guideline: Consider whether it's better to rewrite than to comment."),Object(r.b)("p",null,"The need to leave hints in the code indicates that the code itself is in\nneed of reworking. Doing so may remove the need for the trailing\ncomment, or enable it to be re-written so it's more to the point."),Object(r.b)("h3",{id:"95-proofreading"},"9.5 Proofreading"),Object(r.b)("p",null,"Guideline: Check the spelling, syntax, and sanity of your documentation."),Object(r.b)("p",null,"To be effective, documentation must communicate effectively. It must be\nwithout distractions (like spelling mistakes), it must be comprehensible\n(i.e., syntactically correct), it must be unambiguous, and it must make\nsense. So ",Object(r.b)("em",{parentName:"p"},"read")," it after it's written, or, better still, have someone\nwho's unfamiliar with the code read through it."),Object(r.b)("h2",{id:"10-library-functions"},"10 LIBRARY FUNCTIONS"),Object(r.b)("p",null,"Guideline: Use C's Standard Library functions wherever possible."),Object(r.b)("p",null,"If C provides a way to solve your problem with a Standard Library\nfunction, then it makes no sense to reinvent it. It's likely that\nfunction is faster and better debugged than anything you'll have time to\nwrite yourself."),Object(r.b)("p",null,"Bear in mind, some of C's built-in functions are complex, with subtle\nbehaviour, so there are right and wrong ways to use them. Note also that\nthe C Standard allows any function declared in a header to be\nadditionally implemented as a macro defined in the header."),Object(r.b)("p",null,"Here are some guidelines."),Object(r.b)("h3",{id:"101-asserth"},"10.1 <assert.h",">"),Object(r.b)("p",null,"Guideline: Use assert only in development code. The sole purpose of the\nheader ",Object(r.b)("inlineCode",{parentName:"p"},"<assert.h>")," is to provide a definition of the macro assert. The\nmacro is used to enforce assertions at critical places within your\nprogram:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"assert(0 <= idx && idx < sizeof a / sizeof a[0]);\n")),Object(r.b)("p",null,"If the assertion is false, a suitably revealing message is written to\nthe standard error stream and the program terminates abnormally by\ncalling ",Object(r.b)("inlineCode",{parentName:"p"},"abort"),"."),Object(r.b)("p",null,"However, such behaviour should be used only in development code and\n",Object(r.b)("em",{parentName:"p"},"not")," in production code. Some form of error recovery is always\npreferred."),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10133-abort"}),"\xa710.13.3"),"."),Object(r.b)("h3",{id:"102-ctypeh"},"10.2 <ctype.h",">"),Object(r.b)("h4",{id:"1021-input-functions"},"10.2.1 Input Functions"),Object(r.b)("p",null,"Guideline: Use the functions declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<ctype.h>")," to test or alter\ncharacters that you read in with ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"getc()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"getchar()"),", all\ndeclared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>"),"."),Object(r.b)("p",null,"If you store a value returned by any of those functions before you test\nit, declare the object to have type ",Object(r.b)("inlineCode",{parentName:"p"},"int"),". The functions work properly\nonly for the value ",Object(r.b)("inlineCode",{parentName:"p"},"EOF"),", defined in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>"),", and values that type\n",Object(r.b)("inlineCode",{parentName:"p"},"unsigned char")," can represent."),Object(r.b)("h4",{id:"1022-letter-codes"},"10.2.2 Letter Codes"),Object(r.b)("p",null,"Guideline: Do not assume letter codes are adjacent."),Object(r.b)("p",null,"Write your code to be independent of the underlying character set used\nby the compiler."),Object(r.b)("p",null,"For example, in the ASCII character set, it happens that letter codes\nare adjacent, but in the EBCDIC character set they are not."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"<ctype.h>")," defines a family of functions that provide tests and\nconversions that are independent of character set. Use those functions\ninstead of your own. For example, the following assumes ASCII and that\nupper case and lower case letters are a fixed distance apart:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\n/* lower: convert c to lower case; ASCII only */\nint lower(int c)\n{\n    if ('A' <= c && c <= 'Z')\n        return c + 'a' -- 'A';\n    else\n        return c;\n}\n")),Object(r.b)("p",null,"It will not work for the EBCDIC character set. ",Object(r.b)("inlineCode",{parentName:"p"},"tolower(c)")," will work,\nwhatever character set is used."),Object(r.b)("p",null,"The issue of the underlying character set has implications for number\nconversion, for example converting a hexadecimal number in any locale.\nSee the sample code in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#17-useful-macro-and-function-examples"}),"Section 17"),"."),Object(r.b)("h3",{id:"103-errnoh"},"10.3 <errno.h",">"),Object(r.b)("hr",null),Object(r.b)("p",null,"Guideline: Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),"."),Object(r.b)("p",null,"The C Standard leaves much unsaid about the errors that can be reported,\nand even less about the values of any error codes or the macro names\nused to determine those values. Behaviours are explicitly stated in the\nC Standard, so if you call ",Object(r.b)("inlineCode",{parentName:"p"},"sqrt(-1.0)")," you will know ",Object(r.b)("inlineCode",{parentName:"p"},"errno")," contains the\nvalue ",Object(r.b)("inlineCode",{parentName:"p"},"EDOM"),". However, call ",Object(r.b)("inlineCode",{parentName:"p"},"fabs(x)")," and all bets are off. If a function\ndoes not document it changes ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),", it can do so silently (although no\nfunction will ever set it to 0). Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),"."),Object(r.b)("p",null,"Reference: Ref 5 Chapter 3; Ref 7 Rule 20.5."),Object(r.b)("h3",{id:"104-floath"},"10.4 <float.h",">"),Object(r.b)("hr",null),Object(r.b)("p",null,"The three pitfalls of floating-point arithmetic are overflow, underflow,\nand significance loss. These Guidelines describe ways to use the macros\ndefined in ",Object(r.b)("inlineCode",{parentName:"p"},"float.h")," to perform double arithmetic more safely. The\nfunctions in the following examples are the common maths functions\ndeclared in ",Object(r.b)("inlineCode",{parentName:"p"},"math.h"),"."),Object(r.b)("h4",{id:"1041-overflow"},"10.4.1 Overflow"),Object(r.b)("p",null,"Guideline: To avoid overflow, make sure that no value ever exceeds\n",Object(r.b)("inlineCode",{parentName:"p"},"DBL_MAX")," in magnitude."),Object(r.b)("p",null,"To conform to this guideline, you cannot simply write:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (DBL_MAX < fabs(y)) /* SILLY TEST */\n. . .\n")),Object(r.b)("p",null,"By the time you've made the test, it's too late."),Object(r.b)("p",null,"A more sensible test might be:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (x < log(DBL_MAX))\n    y = exp(x);\nelse\n. . . /* HANDLE OVERFLOW */\n")),Object(r.b)("p",null,"To avoid computing ",Object(r.b)("inlineCode",{parentName:"p"},"log(DBL_MAX)"),", use a related macro, for example,"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (x <= FLT_MAX_10_EXP)\n    y = pow(10, x);\nelse\n    . . . /* HANDLE OVERFLOW */\n")),Object(r.b)("h4",{id:"1042-underflow"},"10.4.2 Underflow"),Object(r.b)("p",null,"Guideline: To avoid underflow, make sure that no value ever goes below\n",Object(r.b)("inlineCode",{parentName:"p"},"DBL_MIN")," in magnitude."),Object(r.b)("p",null,"You can make the following test :"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (fabs(y) < DBL_MIN)\n. . .    /* UNDERFLOW HAS OCCURRED */\n")),Object(r.b)("p",null,"Although not as silly as the corresponding comparison between ",Object(r.b)("inlineCode",{parentName:"p"},"DBL_MAX"),",\nthe test is performed only after any damage has been done."),Object(r.b)("p",null,"You can make the corresponding tests:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (log(DBL_MIN) <= x)\n   y = exp(x);\nelse\n   . . . /* HANDLE UNDERFLOW */\n\nif (FLT_MIN10_EXP <= x)\n    y = pow(10, x);\nelse\n    . . . /* HANDLE UNDERFLOW */\n\nif (FLT_MIN_EXP < n)\n   y = ldexp(1.0, n);\nelse\n   . . . /* HANDLE UNDERFLOW */\n")),Object(r.b)("h4",{id:"1043-significance-loss"},"10.4.3 Significance Loss"),Object(r.b)("p",null,"Guideline: Where possible, perform a check when adding a small magnitude\nto a large one."),Object(r.b)("p",null,"Significance loss occurs when you subtract two values that are nearly\nequal. Nothing can save you from such a fate except careful analysis of\nthe problem before you write code. However, you can protect against a\nsubtler form of significance loss \u2014 adding a small magnitude to a\nlarge one."),Object(r.b)("p",null,"So, to test, for example, whether adding ",Object(r.b)("inlineCode",{parentName:"p"},"x")," to ",Object(r.b)("inlineCode",{parentName:"p"},"y")," captures at least three\ndecimal digits of significance from ",Object(r.b)("inlineCode",{parentName:"p"},"y")," (assuming both are positive),\nwrite:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (x < y * DBL_EPSILON * 1.0E+03)\n    . . . /* HANDLE SIGNIFICANCE LOSS */\n")),Object(r.b)("p",null,"Note that ",Object(r.b)("inlineCode",{parentName:"p"},"<float.h>")," does not contain some key ingredient for writing\nhighly portable code."),Object(r.b)("p",null,"References: Plauger Chapter 4."),Object(r.b)("h3",{id:"105-limitsh"},"10.5 <limits.h",">"),Object(r.b)("p",null,"Guideline: Wherever possible, use the macros provided in ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," to\ntest the execution environment. Do not do experiments on the\npre-processor."),Object(r.b)("p",null,"Preprocessor arithmetic need not model that of the execution\nenvironment. Although the translator must closely model the execution\nenvironment, it can largely define its own environment for the\narithmetic within ",Object(r.b)("inlineCode",{parentName:"p"},"#if")," directives."),Object(r.b)("p",null,"The tradition in C is that scalar data types are represented in ways\nnatural to each computer architecture. ",Object(r.b)("inlineCode",{parentName:"p"},"int")," is particularly elastic. It\nwants to be a size that supports efficient computation, at least within\nbroad limits. That is great for efficiency, but a real nuisance for\nportability."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," captures many important properties that can change across\narchitectures, and it deals exclusively with integer types. When similar\ndata were added for floating point types, the Standards committee\ndecided not to include them in ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>"),". Instead, they added them to\n",Object(r.b)("inlineCode",{parentName:"p"},"<float.h>"),". They could have renamed ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," to ",Object(r.b)("inlineCode",{parentName:"p"},"<integer.h>"),", but\nthey elected not to do so."),Object(r.b)("p",null,"All the macros defined in ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," are testable within ",Object(r.b)("inlineCode",{parentName:"p"},"#if"),"\ndirectives, so rather than use execution environment-type expressions,\ninclude ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," and test the values of the macros it provides. For\nexample:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#include <assert.h>\n#include <limits.h>\n#if VAL_MIN < LONG_MIN || LONG_MAX < VAL_MAX\n    typedef double Val_t;\n#elif VAL_MIN < INT_MIN || INT_MAX < VAL_MAX\n    typedef long Val_t;\n#else\n    typedef int val_t;\n#endif\n")),Object(r.b)("p",null,"You then declare all data objects that must hold this range of values as\nhaving type ",Object(r.b)("inlineCode",{parentName:"p"},"Val_t"),". The program chooses the most efficient type."),Object(r.b)("p",null,"Of course, the macros in ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," can be used in code."),Object(r.b)("h3",{id:"106-localeh"},"10.6 <locale.h",">"),Object(r.b)("p",null,"Guideline: Be aware of where library behaviour changes with locale."),Object(r.b)("p",null,"When using locales, be aware of where library behaviour changes. Here\nare all the places where library behaviour changes with locale."),Object(r.b)("p",null,"10.6.1 The functions ",Object(r.b)("inlineCode",{parentName:"p"},"strcoll")," and ",Object(r.b)("inlineCode",{parentName:"p"},"strxfrm"),", declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<string.h>"),", can change how they collate when category ",Object(r.b)("inlineCode",{parentName:"p"},"LC_COLLATE")," changes."),Object(r.b)("p",null,"10.6.2 The functions declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<ctype.h"),">, the print and scan functions, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>"),", and the numeric conversion functions, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdlib.h>"),", can change how they test and alter certain characters when category ",Object(r.b)("inlineCode",{parentName:"p"},"LC_TYPE")," changes."),Object(r.b)("p",null,"10.6.3 The multibyte functions, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdlib.h>")," and the print and scan functions, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>")," can change how they parse and translate multibyte strings when category ",Object(r.b)("inlineCode",{parentName:"p"},"LC_CTYPE")," changes."),Object(r.b)("p",null,"10.6.4 The print and scan functions, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"atof")," and ",Object(r.b)("inlineCode",{parentName:"p"},"strtod"),", declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdlib.h>"),", can change what they use for the decimal point character when category ",Object(r.b)("inlineCode",{parentName:"p"},"LC_NUMERIC")," changes."),Object(r.b)("p",null,"10.6.5 The ",Object(r.b)("inlineCode",{parentName:"p"},"strftime")," function, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<time.h>"),", can change how it converts times to character strings when category ",Object(r.b)("inlineCode",{parentName:"p"},"LC_TIME")," changes."),Object(r.b)("p",null,"10.6.6 The ",Object(r.b)("inlineCode",{parentName:"p"},"localeconv")," function, declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<locale.h>"),", can change what it returns when categories ",Object(r.b)("inlineCode",{parentName:"p"},"LC_MONETARY")," or ",Object(r.b)("inlineCode",{parentName:"p"},"LC_NUMERIC")," change."),Object(r.b)("h3",{id:"107-mathh"},"10.7 <math.h",">"),Object(r.b)("p",null,"Programmers that use ",Object(r.b)("inlineCode",{parentName:"p"},"<math.h>")," have a good idea of what they intend to\ndo with the functions declared in it; therefore, there is no guideline\nfor the Standard Library header file. Section 10.4 uses some of the\nfunctions."),Object(r.b)("h3",{id:"108-setjmph"},"10.8 <setjmp.h",">"),Object(r.b)("p",null,"Guideline: Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"setjmp")," or ",Object(r.b)("inlineCode",{parentName:"p"},"longjmp"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"<setjmp.h>")," is used when you want to bypass the normal function call\nand return mechanism. For those reasons, these Guidelines mandate that\nit is not used."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 20.7."),Object(r.b)("h3",{id:"109-signalh"},"10.9 <signal.h",">"),Object(r.b)("hr",null),Object(r.b)("p",null,"Guideline: Do not use the signal handling facilities of ",Object(r.b)("inlineCode",{parentName:"p"},"<signal.h>"),"."),Object(r.b)("p",null,"Signal handling is essentially nonportable, so do not use it."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 20.8."),Object(r.b)("h3",{id:"1010-stdargh"},"10.10 <stdarg.h",">"),Object(r.b)("p",null,"Guideline: When using the macros in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdarg.h>")," be aware of the caveats\nlisted in this Guideline."),Object(r.b)("p",null,"Here are the caveats for using the macros in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdarg.h>"),":"),Object(r.b)("p",null,"10.10.1 You must declare a function explicitly as having a variable argument list, (call it ",Object(r.b)("inlineCode",{parentName:"p"},"f"),"). Its argument list must end in ellipsis (, ...), both in its definition and any declarations."),Object(r.b)("p",null,"10.10.2 All calls to function ",Object(r.b)("inlineCode",{parentName:"p"},"f")," must be in scope of a function prototype that declares the function in the way described in Para. 10.10.1."),Object(r.b)("p",null,"10.10.3 You must declare the function with at least one fixed argument. The last of these fixed arguments is conventionally referred to as ",Object(r.b)("inlineCode",{parentName:"p"},"parmN"),"."),Object(r.b)("p",null,"10.10.4 You must declare a data object of type ",Object(r.b)("inlineCode",{parentName:"p"},"va_list"),", conventionally called ",Object(r.b)("inlineCode",{parentName:"p"},"ap"),", which is visible within the function."),Object(r.b)("p",null,"10.10.5 You must execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_start(ap, parmN)")," ",Object(r.b)("em",{parentName:"p"},"within")," ",Object(r.b)("inlineCode",{parentName:"p"},"f"),". You must not execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_list")," or ",Object(r.b)("inlineCode",{parentName:"p"},"va_end")," until you do so."),Object(r.b)("p",null,"10.10.6 You can then execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_arg(ap,")," ",Object(r.b)("em",{parentName:"p"},"T"),Object(r.b)("inlineCode",{parentName:"p"},")")," in the function or in any of the functions that it calls. You must specify the proper types for each of the arguments and in the order they appear in the function call. ",Object(r.b)("inlineCode",{parentName:"p"},"va_arg")," is an rvalue macro. You cannot use the macro invocation as an lvalue to alter the value stored in the argument data object."),Object(r.b)("p",null,"10.10.7 You must not write a type ",Object(r.b)("em",{parentName:"p"},"T")," that widens when passed as an argument. Replace ",Object(r.b)("inlineCode",{parentName:"p"},"float")," with ",Object(r.b)("inlineCode",{parentName:"p"},"double"),". Replace ",Object(r.b)("inlineCode",{parentName:"p"},"char"),", ",Object(r.b)("inlineCode",{parentName:"p"},"signed char"),", ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned char"),", ",Object(r.b)("inlineCode",{parentName:"p"},"short"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned short")," with either ",Object(r.b)("inlineCode",{parentName:"p"},"int")," or ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned int"),". Use ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned int")," for an ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned short")," that is the same size as ",Object(r.b)("inlineCode",{parentName:"p"},"int"),". Rarer still, use ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned int")," for a character type that represents no negative values and is the same size as ",Object(r.b)("inlineCode",{parentName:"p"},"int"),"."),Object(r.b)("p",null,"10.10.8 You must write only a type ",Object(r.b)("em",{parentName:"p"},"T")," that can be converted to a pointer type by appending a ",Object(r.b)("inlineCode",{parentName:"p"},"*"),". For example, the type designators ",Object(r.b)("inlineCode",{parentName:"p"},"int")," and ",Object(r.b)("inlineCode",{parentName:"p"},"char\xa0*")," are valid. The type ",Object(r.b)("inlineCode",{parentName:"p"},"char\xa0(*)[5]")," is not. As a general rule, be wary of type designators that contain parentheses or brackets."),Object(r.b)("p",null,"10.10.9 You must execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_end")," within ",Object(r.b)("inlineCode",{parentName:"p"},"f")," if you earlier executed ",Object(r.b)("inlineCode",{parentName:"p"},"va_start"),". Once you execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_end")," you must not again execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_arg")," unless you first execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_start")," to initiate a rescan. In that case, you must execute ",Object(r.b)("inlineCode",{parentName:"p"},"va_end")," again before the function returns."),Object(r.b)("h3",{id:"1011-stddefh"},"10.11 <stddef.h",">"),Object(r.b)("p",null,"This library function contains several types and macros, some of which\nare defined in other headers."),Object(r.b)("h4",{id:"10111-size_t"},"10.11.1 size_t"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"size_t")," ",Object(r.b)("em",{parentName:"p"},"anywhere")," your program performs array\nsubscripting or address arithmetic."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"size_t")," is the safest type to represent any integer data object you use\nas an array subscript. You don't have to worry if a small array evolves\nto a very large one as the program changes. Subscript arithmetic will\nnever overflow when performed in type ",Object(r.b)("inlineCode",{parentName:"p"},"size_t"),". You don't have to worry if\nthe program moves to a machine with peculiar properties, such as 32-bit\nbytes and 1-byte longs. ",Object(r.b)("inlineCode",{parentName:"p"},"size_t")," offers the greatest chance your code\nwon't be unduly surprised. The only sensible type to use for computing\nthe sizes of data objects is ",Object(r.b)("inlineCode",{parentName:"p"},"size_t"),"."),Object(r.b)("p",null,"10.11.2 Be aware of these pitfalls, though: unsigned-integer arithmetic has more pitfalls than signed. You cannot run an unsigned counter down until it goes negative --- it never will. Counting down to zero may lead to clumsy tests. You may occasionally miss the convenience of using negative values (such as ",Object(r.b)("inlineCode",{parentName:"p"},"EOF"),") and testing for them easily. However, the improvement in robustness is well worth the learning investment."),Object(r.b)("h3",{id:"1012-stdioh"},"10.12 <stdio.h",">"),Object(r.b)("p",null,"Most of the functions declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdio.h>")," operate on a stream that\nis associated with an open file."),Object(r.b)("h4",{id:"10121-gets"},"10.12.1 gets"),Object(r.b)("p",null,"Guideline: Function ",Object(r.b)("inlineCode",{parentName:"p"},"gets")," shall not be used."),Object(r.b)("p",null,"Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"gets"),". You have no way of limiting the number of characters it\nreads. Use ",Object(r.b)("inlineCode",{parentName:"p"},"fgets")," instead."),Object(r.b)("h4",{id:"10122-getc"},"10.12.2 getc"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"getc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"getc")," has the same specification as ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc")," but is far more likely to have\na masking macro that dramatically improves performance. As a rule,\ntherefore, you should use ",Object(r.b)("inlineCode",{parentName:"p"},"getc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc"),"."),Object(r.b)("h4",{id:"10123-putc"},"10.12.3 putc"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"putc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fputc"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"putc")," has the same specification as ",Object(r.b)("inlineCode",{parentName:"p"},"fputc")," but is far more likely to have\na masking macro that dramatically improves performance. Therefore, use\n",Object(r.b)("inlineCode",{parentName:"p"},"putc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fputc"),"."),Object(r.b)("h4",{id:"10124-fread"},"10.12.4 fread"),Object(r.b)("p",null,"Guideline: Call ",Object(r.b)("inlineCode",{parentName:"p"},"fread")," in a way such that it can report how many\nadditional characters it read (if any)."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"fread")," is used to read binary data into an array data object or to read\nup to a fixed number of characters from any stream. If the size (second)\nargument is greater than one, you cannot determine whether the function\nalso read up to ",Object(r.b)("inlineCode",{parentName:"p"},"size"),"-1 additional characters beyond what it reports.\nAs a rule, call the function as ",Object(r.b)("inlineCode",{parentName:"p"},"fread(buf, 1, size * n, stream)")," instead\nof ",Object(r.b)("inlineCode",{parentName:"p"},"fread(buf, size, n, stream)"),"."),Object(r.b)("h4",{id:"10125-remove"},"10.12.5 remove"),Object(r.b)("p",null,"Guideline: Always use ",Object(r.b)("inlineCode",{parentName:"p"},"remove")," to remove any files you created with ",Object(r.b)("inlineCode",{parentName:"p"},"tmpnam"),"."),Object(r.b)("p",null,"This is simply good manners, and ensures temporary files names are not\nleft on the system."),Object(r.b)("h4",{id:"10126-rename"},"10.12.6 rename"),Object(r.b)("p",null,"Guideline: Always check the return value of ",Object(r.b)("inlineCode",{parentName:"p"},"rename")," to see if the\noperation succeeded."),Object(r.b)("p",null,"If ",Object(r.b)("inlineCode",{parentName:"p"},"rename")," fails and the file existed previously, it is still known by\nits original name."),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#121-function"}),"Guideline 12.1"),"."),Object(r.b)("h4",{id:"10127-rewind"},"10.12.7 rewind"),Object(r.b)("p",null,"Guideline: Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"rewind"),"."),Object(r.b)("p",null,"Unlike the other file-positioning functions, ",Object(r.b)("inlineCode",{parentName:"p"},"rewind")," clears the error\nindicator for a stream. It also reports no failures. Use ",Object(r.b)("inlineCode",{parentName:"p"},"fseek(stream,\n0, SEEK_SET)")," and ",Object(r.b)("inlineCode",{parentName:"p"},"clearerr(stream)")," as needed instead."),Object(r.b)("h4",{id:"10128-setbuf"},"10.12.8 setbuf"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"setvbuf")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"setbuf"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"setvbuf")," will get you more control. But be aware it is usually best to\nlet the Standard C library decide how to buffer input/output."),Object(r.b)("h4",{id:"10129-tmpfile"},"10.12.9 tmpfile"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"tmpfile")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"tmpnam")," wherever possible."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"tmpfile")," opens the file for you and arranges to have it closed and\nremoved on program termination. tmpnam requires you to assume more of\nthe responsibilities."),Object(r.b)("h3",{id:"1013-stdlibh"},"10.13 <stdlib.h",">"),Object(r.b)("hr",null),Object(r.b)("h4",{id:"10131-heap-overhead"},"10.13.1 Heap Overhead"),Object(r.b)("p",null,"10.13.1.1 Guideline: Gather related data into a structure and allocate it all at once. Do ",Object(r.b)("em",{parentName:"p"},"not")," gather unrelated data just to save heap overhead."),Object(r.b)("p",null,"Gathering related data into a structure is good programming practice.\nBut do not do it at the cost of placing unrelated data into the\nstructure."),Object(r.b)("p",null,"References: Plauger Chapter 13."),Object(r.b)("p",null,"10.13.1.2 Guideline: Allocate data objects with similar lifetimes all at once, then free them at about the same time. Do ",Object(r.b)("em",{parentName:"p"},"not")," advance or defer unrelated heap operations just to minimize fragmentation."),Object(r.b)("p",null,"Allocating and freeing data objects at about the same time is good\nprogramming practice, but do not do it at the cost of advancing or\ndelaying allocation and freeing."),Object(r.b)("h4",{id:"10132-exit_failure-and-exit-success"},"10.13.2 ",Object(r.b)("inlineCode",{parentName:"h4"},"EXIT_FAILURE")," and ",Object(r.b)("inlineCode",{parentName:"h4"},"EXIT SUCCESS")),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"EXIT_FAILURE")," and ",Object(r.b)("inlineCode",{parentName:"p"},"EXIT SUCCESS")," as the argument to ",Object(r.b)("inlineCode",{parentName:"p"},"exit")," or\nthe return value from ",Object(r.b)("inlineCode",{parentName:"p"},"main")," to report unsuccessful and successful program\ntermination."),Object(r.b)("p",null,"Use only these macros as the values returned by ",Object(r.b)("inlineCode",{parentName:"p"},"main"),". You can use zero\nto indicate successful termination, but any other value will have\ndifferent meanings on different operating systems."),Object(r.b)("h4",{id:"10133-abort"},"10.13.3 ",Object(r.b)("inlineCode",{parentName:"h4"},"abort")),Object(r.b)("p",null,"Guideline: Wherever possible, call ",Object(r.b)("inlineCode",{parentName:"p"},"exit(EXIT_FAILURE)")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"abort"),"."),Object(r.b)("p",null,"When you call ",Object(r.b)("inlineCode",{parentName:"p"},"abort"),", you cannot be sure that input/output streams are\nflushed, files are closed properly, or temporary files are removed."),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#101-asserth"}),"Guideline 10.1"),"."),Object(r.b)("h4",{id:"10134-abs"},"10.13.4 ",Object(r.b)("inlineCode",{parentName:"h4"},"abs")),Object(r.b)("p",null,"Guideline: Call ",Object(r.b)("inlineCode",{parentName:"p"},"abs(x)")," instead of writing the idiom ",Object(r.b)("inlineCode",{parentName:"p"},"x < 0 ? --x : x"),"."),Object(r.b)("p",null,"Many Standard C translators generate inline code for ",Object(r.b)("inlineCode",{parentName:"p"},"abs")," that is smaller\nand faster than the idiom. Also, you avoid the occasional surprise when\nyou inadvertently evaluate twice an expression with side effects."),Object(r.b)("p",null,"On a two's complement machine, ",Object(r.b)("inlineCode",{parentName:"p"},"abs")," can generate an overflow."),Object(r.b)("h4",{id:"10135-atof"},"10.13.5 atof"),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"strtod")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"atof"),"."),Object(r.b)("p",null,"The call ",Object(r.b)("inlineCode",{parentName:"p"},"atof(s)")," is equivalent to ",Object(r.b)("inlineCode",{parentName:"p"},"strtod(s, NULL)"),", except that ",Object(r.b)("inlineCode",{parentName:"p"},"atof")," is\nnot obliged to store ",Object(r.b)("inlineCode",{parentName:"p"},"ERANGE")," in ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),". You also get no indication with\n",Object(r.b)("inlineCode",{parentName:"p"},"atof")," of how many characters from the string pointed to by ",Object(r.b)("inlineCode",{parentName:"p"},"s")," participate\nin the conversion."),Object(r.b)("h4",{id:"10136-calloc"},"10.13.6 calloc"),Object(r.b)("h5",{id:"101361-initialising-to-zero"},"10.13.6.1 Initialising to zero."),Object(r.b)("p",null,"Guideline: Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"calloc")," to initialise floating-point values to\nzeros, or pointers to null pointers."),Object(r.b)("p",null,"A null pointer is not necessarily zero, and the floating-point\nrepresentation of 0 may not be all bits zero, so do not rely on ",Object(r.b)("inlineCode",{parentName:"p"},"calloc"),"\nto initialise to those values."),Object(r.b)("p",null,"However, ",Object(r.b)("inlineCode",{parentName:"p"},"calloc")," will yield the value 0 for all integral types, including\n'\\0' for character types."),Object(r.b)("p",null,"See also: ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#75-null-pointers"}),"Section 7.5"),"."),Object(r.b)("p",null,"References: Ref 5 Chapter 13."),Object(r.b)("h5",{id:"101362-product-of-arguments"},"10.13.6.2 Product of Arguments"),Object(r.b)("p",null,"Guideline: Do not assume the product of ",Object(r.b)("inlineCode",{parentName:"p"},"calloc"),"'s arguments is all that\nmatters."),Object(r.b)("p",null,"An implementation can select a storage alignment for the allocated data\nobjects based on the size specified by the second argument. Thus you\nshould allocate an array of ",Object(r.b)("inlineCode",{parentName:"p"},"N")," ",Object(r.b)("inlineCode",{parentName:"p"},"int")," as"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"calloc(N, sizeof (int))\n")),Object(r.b)("p",null,"a data object of type ",Object(r.b)("inlineCode",{parentName:"p"},"struct x")," as"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"calloc(1, sizeof (struct x))\n")),Object(r.b)("p",null,"These second-argument considerations also apply to ",Object(r.b)("inlineCode",{parentName:"p"},"malloc"),"."),Object(r.b)("h3",{id:"1014-stringh"},"10.14 <string.h",">"),Object(r.b)("h4",{id:"10141--mem-functions"},"10.14.1 ",Object(r.b)("a",{name:"10.14.1"})," ",Object(r.b)("inlineCode",{parentName:"h4"},"mem")," Functions"),Object(r.b)("p",null,"Guideline: If a string can contain null characters, specify its length\nand use functions whose names begin with ",Object(r.b)("inlineCode",{parentName:"p"},"mem"),"."),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"memmove")," to copy a string if the source and destination\nstrings might overlap."),Object(r.b)("h4",{id:"10142--strn-functions"},"10.14.2 ",Object(r.b)("a",{name:"10.14.2"})," ",Object(r.b)("inlineCode",{parentName:"h4"},"strn")," Functions"),Object(r.b)("p",null,"Guideline: If a string may or may not have a terminating null character,\nspecify its maximum length and use the functions beginning with ",Object(r.b)("inlineCode",{parentName:"p"},"strn"),"."),Object(r.b)("h4",{id:"10143-str-functions"},"10.14.3 str Functions"),Object(r.b)("p",null,"Guideline: If a string definitely has a terminating null character,\nspecify only the string and use the remaining functions (see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1041-overflow"}),"10.14.1")," and\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10142-strn-functions"}),"10.14.2"),") whose names begin with ",Object(r.b)("inlineCode",{parentName:"p"},"str"),"."),Object(r.b)("h4",{id:"10144-strcat"},"10.14.4 ",Object(r.b)("inlineCode",{parentName:"h4"},"strcat")),Object(r.b)("p",null,"Guideline: Use ",Object(r.b)("inlineCode",{parentName:"p"},"strcat")," if you have only two strings to concatenate, or\njust a few short strings. Otherwise use ",Object(r.b)("inlineCode",{parentName:"p"},"strcpy"),"."),Object(r.b)("p",null,"Using ",Object(r.b)("inlineCode",{parentName:"p"},"strcpy")," in the situations described in the Guideline will save\nrepeated and ever-lengthening rescans of the initial part of the string.\nUse this form:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"strcpy(s1 += strlen(s1), s2)\n")),Object(r.b)("p",null,"Ensure the destination array is large enough to hold the concatenated\nstring."),Object(r.b)("h3",{id:"1015-timeh"},"10.15 <time.h",">"),Object(r.b)("p",null,"Guideline: Always copy the value returned by a call to another (or the\nsame) function if you need the value beyond a conflicting function call."),Object(r.b)("p",null,"The functions in ",Object(r.b)("inlineCode",{parentName:"p"},"<time.h>")," share two static data objects. All functions\nthat return a type of pointer to ",Object(r.b)("inlineCode",{parentName:"p"},"char")," return a pointer to one of these\ndata objects. All pointers that return a value of type pointer to ",Object(r.b)("inlineCode",{parentName:"p"},"struct\ntm")," return a pointer to the other."),Object(r.b)("p",null,"This means a call to one of the functions declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<time.h>")," can\nalter the value stored on behalf of an earlier call to another (or the\nsame) function. Therefore, if you need the value beyond a conflicting\nfunction call, be careful to copy it."),Object(r.b)("h2",{id:"11-support-libraries"},"11 SUPPORT LIBRARIES"),Object(r.b)("p",null,"Guideline: If Glasswall Solutions Limited has a library of support\nroutines that have been reviewed, debugged and tested, and released for\nuse, then those routines should be used rather than a developer writing\nhis her own routines to achieve the same functionality."),Object(r.b)("p",null,"See also ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#17-useful-macro-and-function-examples"}),"Section 17"),"."),Object(r.b)("h2",{id:"12-error-handling"},"12 ERROR HANDLING"),Object(r.b)("h3",{id:"121-function"},"12.1 Function"),Object(r.b)("p",null,"Guideline: If a function returns error information, then that error\ninformation shall be tested."),Object(r.b)("p",null,"Whether a function is user-defined, part of the Standard Library, or\npart of a third party library, if it returns error information, then\nthat information should be tested by the caller immediately after the\nfunction returns."),Object(r.b)("h2",{id:"13-values-and-expressions"},"13 VALUES AND EXPRESSIONS"),Object(r.b)("h3",{id:"131-leading-zeros"},"13.1 Leading Zeros"),Object(r.b)("p",null,"Guideline: Don't use octal constants (except zero) and octal escape\nsequences."),Object(r.b)("p",null,"Several guidelines in the document recommend laying out data in table\nformat, and aligning those data vertically. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'struct atomic_number\n{\n    char *name;\n    int atomic_number;\n} atomic_numbers[] =\n{\n    { "NITROGEN",    7 },\n    { "NIOBIUM",    41 },\n    { "NEODYNIUM",  60 },\n    { "NOBELIUM",  102 },\n};\n')),Object(r.b)("p",null,"However, to make these line up a coder may well pad the atomic numbers so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'struct atomic_number\n{\n    char *name;\n    int atomic_number;\n} atomic_numbers[] =\n{\n    { "NITROGEN",  007 },\n    { "NIOBIUM",   041 },\n    { "NEODYNIUM", 060 },\n    { "NOBELIUM",  102 },\n};\n')),Object(r.b)("p",null,"Unfortunately, this makes them wrong. In C, any integer constant that\nbegins with a zero is interpreted as an octal number."),Object(r.b)("p",null,"To obviate this, do not use octal numbers or escape sequences in your\ncode."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 7.1."),Object(r.b)("h3",{id:"132-multiline-strings"},"13.2 Multiline Strings"),Object(r.b)("p",null,"Guideline: Lay out multiline strings over multiple lines."),Object(r.b)("p",null,"If a string has embedded newline characters, but the entire string won't\nfit on a single line, then break the string after each newline and\nconcatenate the pieces:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'static const char usage[] = "Usage: dump <file> [-full]\\n"\n                            "(Use -full option for full dump)\\n"\n                            ;\n')),Object(r.b)("p",null,"This makes the internal appearance of the string mirror its printed appearance."),Object(r.b)("p",null,"References: K&R2 \xa7A.2.6."),Object(r.b)("h3",{id:"133-comma-operator"},"13.3 Comma Operator"),Object(r.b)("p",null,"Guidline: Don't use commas to sequence statements."),Object(r.b)("p",null,"The comma operator can reduce the readability of code, so their use is\nnot recommended."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 12.10; K&R2 \xa7A.7.18."),Object(r.b)("h3",{id:"134-constants"},"13.4 Constants"),Object(r.b)("p",null,"Guideline: Use symbolic constants to give numbers meaningful names."),Object(r.b)("p",null,"Raw numbers that suddenly appear in the middle of a program are often\nmysterious, frequently confusing, always a potential source of errors,\nand hard to change in a systematic way."),Object(r.b)("p",null,"Replace raw literals with a pre-processor macro whose name explains the\nmeaning of the numbers:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'#define   MOLYBDENUM_ATOMIC_NUMBER   42\n/* and later ... */\nprintf("%d\\n", count * MOLYBDENUM_ATOMIC_NUMBER);\n')),Object(r.b)("p",null,"See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#77-booleans"}),"\xa77.7"),"."),Object(r.b)("p",null,"References: Ref. 7, Appendix E; Ref. 2, \xa71.4."),Object(r.b)("h2",{id:"14-variables"},"14 VARIABLES"),Object(r.b)("h3",{id:"141-global-variables"},"14.1 Global Variables"),Object(r.b)("p",null,"Guideline: Avoid using global variables."),Object(r.b)("p",null,"Using local variables increases the coupling of your code. If two\notherwise unrelated sections of code both use a global variable, those\ntwo pieces of code can interact with each other in very subtle ways,\njust by the way they interact with that global variable."),Object(r.b)("h3",{id:"142-initialisation"},"14.2 Initialisation"),Object(r.b)("p",null,"Guideline: Initialise all automatic variables."),Object(r.b)("p",null,"The initial value of an automatic object not explicitly initialised is\nundefined; therefore, all automatic variables must be explicitly\ninitialised before read."),Object(r.b)("p",null,"References: MISRA-C:2004 Rule 9.1; K&R2 \xa72.4, \xa74.9, \xa7A.8.7."),Object(r.b)("h3",{id:"143-scope"},"14.3 Scope"),Object(r.b)("p",null,"Guideline: Declare data objects within functions at the innermost possible nesting level."),Object(r.b)("p",null,"It is common for programmers to declare all the variables used in a\nfunction at the top of the function, followed by the processing.\nHowever, the control logic in the function may mean variables are\ndeclared that are never used, and can clutter the code, making it\ndifficult for a maintainer to understand the process. So localise\nvariables at the innermost possible level. For example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (validate_agents)\n{\n    int agent_num;\n    for (agent_num = AGENT_NUM_MIN; agent_num < AGENT_NUM_MAX; ++agent_num)\n    ...\n}\n")),Object(r.b)("p",null,"In this example, ",Object(r.b)("inlineCode",{parentName:"p"},"agent_num")," is required only if ",Object(r.b)("inlineCode",{parentName:"p"},"validate_agents")," is true."),Object(r.b)("h2",{id:"15-control-structures"},"15 CONTROL STRUCTURES"),Object(r.b)("h3",{id:"151-linear-coding"},"15.1 Linear Coding"),Object(r.b)("p",null,"Guideline: Reject as many iterations as possible, as early as possible."),Object(r.b)("p",null,"Another guideline recommends coding in paragraphs (See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#69-chunking"}),"6.9"),"). It's also a\ngood idea to code in paragraphs. Don't wait until you have all your data\nassembled before you start processing. It's more efficient, and often\nmore comprehensible, to verify as you go."),Object(r.b)("p",null,"Checking data as soon as it's available means you can short-circuit\nsooner if the data are unacceptable. Also, the resulting sections of\ncode are specific to each datum, rather than to one phase of the\nprocessing. That means your code chunks are better focused on the\ndistinct elements of the problem domain, rather than on the more complex\ninteractions between those elements."),Object(r.b)("p",null,"So, instead of this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* NON-CONFORMANT */\nint i;\nint total = 0;\nfor (i = 0; i \\< nclients; ++i)\n{\n    int value;\n    int projected;\n    Client_t *client;\n\n    client = &clients[i];\n\n    /* calculate current and future client value */\n    value = client-\\>volume \\* client-\\>rate;\n    projected = client-\\>activity \\* value;\n    \n    /* verify client is active, worth watching, and worth keeping \\... */\n    if (client->activity\n        && value > WATCH_LEVEL\n        && projected >= KEEP_LEVEL\n    )\n    {\n        /* if so, add in the client's expected contribution */\n        total += projected * client-\\>volatility;\n    }\n}\n")),Object(r.b)("p",null,"You can generate and test each datum sequentially, like so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"for (i = 0; i \\< nclients; ++i)\n{\n    int value;\n    int rate;\n    int projected;\n    Client_t *client;\n\n    client = &clients[i];\n    /* verify active client */\n    if (!client->activity)\n        continue;\n\n    /* calculate current client value and verify client is worth watching ...*/\n    value = client->volume * client->rate;\n    if (value < WATCH_LEVEL)\n        continue;\n\n    /* compute likely client future value and verify client is worth keeping ... */\n    projected = client->activity * value;\n    if (projected < KEEP_LEVEL)\n        continue;\n\n    /* Add in the client's expected contribution */\n    total += projected * client->volatility;\n}\n")),Object(r.b)("p",null,"NOTE: Use of ",Object(r.b)("inlineCode",{parentName:"p"},"continue")," is non-conformant with MISRA-C:2004 Rule 14.5, but\nthese Guidelines do not ban its use."),Object(r.b)("h2",{id:"16-undefined-behaviours"},"16 UNDEFINED BEHAVIOURS"),Object(r.b)("p",null,"Guideline: C code shall not be written that invokes undefined behaviour."),Object(r.b)("p",null,"The C Standard defines undefined behaviour thus:"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Behaviour, upon use of a nonportable or erroneous program construct or\nof erroneous data, for which this International Standard imposes no\nrequirements.")),Object(r.b)("p",null,"This means the C Standard imposes ",Object(r.b)("em",{parentName:"p"},"no")," requirements on the behaviour of\na compiler faced with an instance of undefined behaviour. The compiler\n(more importantly, any generated code) can do absolutely anything."),Object(r.b)("p",null,"In particular, there is no guarantee that only the undefined part of the\nprogram will behave badly and the rest of the program will perform\nnormally."),Object(r.b)("p",null,"It is perilous to think that you can tolerate undefined behaviour in a\nprogram. The code is broken."),Object(r.b)("p",null,"The following paragraphs detail all the cases that invoke undefined\nbehaviour. None of these shall be used in C source code developed by\nGlasswall Solutions Limited."),Object(r.b)("h3",{id:"161-lexical-conventions---constants----character-constants"},"16.1 Lexical Conventions - Constants -- Character Constants"),Object(r.b)("hr",null),Object(r.b)("p",null,"16.1.1 The octal and hexadecimal escapes have no limit on the number of digits, but the behaviour is undefined if the resulting character value exceeds that of the largest character."),Object(r.b)("p",null,"16.1.2 When specifying an escape sequence, if the character following the \\ is not one of those specified, the behaviour is undefined."),Object(r.b)("p",null,"16.1.3 If an octal or hexadecimal escape is used to specify a wide character constant, and its value exceeds that representable with ",Object(r.b)("inlineCode",{parentName:"p"},"wchar_t"),", the effect is undefined."),Object(r.b)("h3",{id:"162-lexical-conventions----string-literals"},"16.2 Lexical Conventions -- String Literals"),Object(r.b)("p",null,"16.2.1 The behaviour of a program that attempts to alter a string literal is undefined."),Object(r.b)("p",null,"16.2.2 Concatenation of ordinary and wide string literals is undefined."),Object(r.b)("h3",{id:"163-conversions--integer-and-floating"},"16.3 Conversions \u2014 Integer and Floating"),Object(r.b)("p",null,"16.3.1 When a value of floating type is converted to integral type, the fractional part is discarded; if the resulting value can not be represented in the integral type, the behaviour is undefined."),Object(r.b)("p",null,"16.3.2 When a value of integral type is converted to floating, and the value is out of range, the behaviour is undefined."),Object(r.b)("h3",{id:"164-conversions--floating-types"},"16.4 Conversions \u2014 Floating Types"),Object(r.b)("p",null,"16.4.1  When a more precise floating value is converted to a less precise floating type, and the value is out of range, the behaviour is undefined."),Object(r.b)("h3",{id:"165-expressions---postfix-expressions---function-calls"},"16.5 Expressions - Postfix Expressions - Function Calls"),Object(r.b)("p",null,"16.5.1 If the function declaration in scope for a call is old-style, and the number of arguments disagrees with the number of parameters in the definition of the function, the effect of the call is undefined."),Object(r.b)("h3",{id:"166-expressions---multiplicative-operators"},"16.6 Expressions - Multiplicative Operators"),Object(r.b)("p",null,"16.6.1 If the second operand of ",Object(r.b)("inlineCode",{parentName:"p"},"/")," or ",Object(r.b)("inlineCode",{parentName:"p"},"%")," is 0, the result is undefined."),Object(r.b)("h3",{id:"167-expressions---additive-operators"},"16.7 Expressions - Additive Operators"),Object(r.b)("p",null,"16.7.1 If one operand of ",Object(r.b)("inlineCode",{parentName:"p"},"+")," is a pointer to an object in an array, and the other is a value of integral type, the result is undefined if the sum pointer points outside the bounds of the array, except at the first location beyond the high end."),Object(r.b)("p",null,"16.7.2 If two pointers to objects of the same type are subtracted, and the pointers do not point either to the same array or to the first location beyond the high end, the result is undefined."),Object(r.b)("h3",{id:"168-expressions---shift-operators"},"16.8 Expressions - Shift Operators"),Object(r.b)("p",null,"16.8.1 If the right operand of ",Object(r.b)("inlineCode",{parentName:"p"},"<<")," and ",Object(r.b)("inlineCode",{parentName:"p"},">>")," is negative, or greater than or equal to the number of bits in the left expression's type, the result is undefined."),Object(r.b)("h3",{id:"169-expressions---relational-operators"},"16.9 Expressions - Relational Operators"),Object(r.b)("p",null,"16.9.1 Pointer comparison is defined only for parts of the same object, and in the case of an array, to the first location beyond the high end; otherwise it is undefined."),Object(r.b)("h3",{id:"1610-preprocessing"},"16.10 Preprocessing"),Object(r.b)("p",null,"16.10.1 The effect of white space characters other than space and horizontal tab is undefined within preprocessor lines."),Object(r.b)("h2",{id:"1611-preprocessing---macro-definition-and-expansion"},"16.11 Preprocessing - Macro Definition and Expansion"),Object(r.b)("p",null,"16.11.1 Regarding ",Object(r.b)("inlineCode",{parentName:"p"},"##"),": if invalid tokens are produced, or if the result depends on the order of processing of the ",Object(r.b)("inlineCode",{parentName:"p"},"##")," operators, the effect is undefined."),Object(r.b)("h3",{id:"1612-preprocessing---file-inclusion"},"16.12 Preprocessing - File Inclusion"),Object(r.b)("p",null,"16.12.1 In the control line ",Object(r.b)("inlineCode",{parentName:"p"},"#include <"),Object(r.b)("em",{parentName:"p"},"filename"),Object(r.b)("inlineCode",{parentName:"p"},">"),", if the name ",Object(r.b)("em",{parentName:"p"},"filename")," contains any of double quote (\"), single quote ('), backslash (","\\",") or forward slash followed immediately by asterisk (/*), the effect is undefined."),Object(r.b)("p",null,"16.12.2 Similarly, in the control line ",Object(r.b)("inlineCode",{parentName:"p"},'#include "'),Object(r.b)("em",{parentName:"p"},"filename"),Object(r.b)("inlineCode",{parentName:"p"},'"'),", if the name ",Object(r.b)("em",{parentName:"p"},"filename")," contains any of single quote ('), backslash (","\\",") or forward slash followed immediately by asterisk (/*), the effect is undefined."),Object(r.b)("p",null,"Thus, sequences of characters that resemble escape sequences cause undefined behaviour. This means you ",Object(r.b)("em",{parentName:"p"},"must not")," use the Windows' directory delimiter character backslash (","\\",") when specifying a file path."),Object(r.b)("h3",{id:"1613-input-and-output-stdioh---file-operations"},"16.13 Input and Output: ",Object(r.b)("inlineCode",{parentName:"h3"},"<stdio.h"),"> - File Operations"),Object(r.b)("p",null,"16.13.1 ",Object(r.b)("inlineCode",{parentName:"p"},"int fflush(FILE *stream)"),": If ",Object(r.b)("inlineCode",{parentName:"p"},"stream")," is an input stream, the result is undefined."),Object(r.b)("h3",{id:"1614-input-and-output-stdioh---formatted-output"},"16.14 Input and Output: ",Object(r.b)("inlineCode",{parentName:"h3"},"<stdio.h>")," - Formatted Output"),Object(r.b)("p",null,"16.14.1 ",Object(r.b)("inlineCode",{parentName:"p"},"printf"),", ",Object(r.b)("inlineCode",{parentName:"p"},"fprintf"),", ",Object(r.b)("inlineCode",{parentName:"p"},"sprintf"),": If the character after the ",Object(r.b)("inlineCode",{parentName:"p"},"%")," is not a conversion character, the behaviour is undefined."),Object(r.b)("h3",{id:"1615-string-functions-stringh"},"16.15 String Functions: ",Object(r.b)("inlineCode",{parentName:"h3"},"<string.h>")),Object(r.b)("p",null,"16.15.1 Except for ",Object(r.b)("inlineCode",{parentName:"p"},"memmove"),", the behaviour is undefined if copying takes place between overlapping objects."),Object(r.b)("h3",{id:"1616-linkages-of-identifiers"},"16.16 Linkages of Identifiers"),Object(r.b)("p",null,"16.16.1 If, within a translation unit, the same identifier appears with both internal and external linkage, the behaviour is undefined."),Object(r.b)("h3",{id:"1617-storage-duration-of-objects"},"16.17 Storage Duration of Objects"),Object(r.b)("p",null,"16.17.1 If an object is referred to outside of its lifetime, the behaviour is undefined."),Object(r.b)("p",null,"###16.18 Conversions - Other Operands -- Pointers\n16.18.1 A pointer to an object or incomplete type may be converted to a pointer to a different object or incomplete type. If the resulting pointer is not correctly aligned for the pointed-to type, the behaviour is undefined."),Object(r.b)("h3",{id:"1619-expressions---postfix-operators---function-calls"},"16.19 Expressions - Postfix Operators - Function Calls"),Object(r.b)("p",null,"16.19.1 If the number of arguments does not equal the number of parameters, the behaviour is undefined."),Object(r.b)("p",null,"16.19.2 If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, ...) or the types of the arguments after promotion are not compatible with the types of the parameters, the behaviour is undefined."),Object(r.b)("p",null,"16.19.3 If the function is defined with a type that does not include a prototype, and the types of the arguments after promotion are not compatible with those of the parameters after promotion, the behaviour is undefined, except for the following cases:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"one promoted type is a signed integer type, the other promoted type\nis the corresponding unsigned integer type, and the value is\nrepresentable in both types;")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"both types are pointers to qualified or unqualified versions of a\ncharacter type or void."))),Object(r.b)("h3",{id:"1620-character-handling"},"16.20 Character Handling"),Object(r.b)("p",null,"16.20.1 The header ",Object(r.b)("inlineCode",{parentName:"p"},"<ctype.h>")," declares several functions useful for classifying and mapping characters. In all cases the argument is an ",Object(r.b)("inlineCode",{parentName:"p"},"int"),", the value of which shall be representable as an ",Object(r.b)("inlineCode",{parentName:"p"},"unsigned char")," or shall equal the value of the macro ",Object(r.b)("inlineCode",{parentName:"p"},"EOF"),". If the argument has any other value, the behaviour is undefined."),Object(r.b)("h3",{id:"1621-environment---hosted-environment"},"16.21 Environment - Hosted Environment"),Object(r.b)("p",null,"16.21.1 If a program in a hosted environment does not define a function named ",Object(r.b)("inlineCode",{parentName:"p"},"main")," using one of these specified forms (or equivalent, e.g. ",Object(r.b)("inlineCode",{parentName:"p"},"argv")," can be written as ",Object(r.b)("inlineCode",{parentName:"p"},"char\xa0**\xa0argv"),", and so on), the behaviour is undefined:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"int main(void) { /* ... */ }\nint main(int argc, char *argv[]) { /* ... */ }\n")),Object(r.b)("h2",{id:"17-useful-macro-and-function-examples"},"17 USEFUL MACRO AND FUNCTION EXAMPLES"),Object(r.b)("h3",{id:"171-macros"},"17.1 Macros"),Object(r.b)("h4",{id:"1711-string-comparisons"},"17.1.1 String Comparisons"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#define STREQ(s, t) (strcmp(s, t) == 0)\n#define STRLT(s, t) (strcmp(s, t) < 0)\n#define STRGT(s, t) (strcmp(s, t) > 0)\n")),Object(r.b)("p",null,"Example use:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (STREQ(ident, p->ident))\n    return p;\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"if (STRLT(authors->prev, curr_author))\n    /* process ... */\n")),Object(r.b)("h4",{id:"1712-miscellaneous-macros"},"17.1.2 Miscellaneous Macros"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"#define NELEMENTS(a) (sizeof(a) / sizeof(a\\[0\\]))\n\n/* Example usage */\nfor (i = 0; i < NELEMENTS(names) && names[i] != NULL; ++i)\n    /* do something with names[i] */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* Swap two objects */\n#define SWAP(a, b, t) (t = a, a = b, b = t)\n\n/* Example usage */\nSWAP(a[lo], a[mid], tmp);\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* get a line of text; return EOF on fail, or string length on success */\n#define GETLN(s, n) ((fgets(s, n, stdin)==NULL) ? EOF : strlen(s))\n\n/* example usage */\nif ((filename_len = GETLN(filename, sizeof filename)) != EOF)\nfor (i = 0; i < filename_len; ++i)\n    /* process each character */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* start an infinite loop */\n#define FOREVER for (;;)\n\n/* Example usage */\nFOREVER\n{\n    /* process forever; exit with break, return, or exit */\n}\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* loop n times, using i to count. Do not use i in loop body */\n#define LOOPDN(r, n) for (r = n+1; --r > 0; )\n\n/* Example usage */\nLOOPDN(i, element_size)\n{\n    SWAP(*a, *b, tmp);\n    ++a, ++b;\n}\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* copy a structure */\n#define STRUCTASST(a, b) memcpy(&(a), &(b), sizeof(a))\n\n/* Example usage */\n/* copy structure struct_b to structure struct_a */\nSTRUCTASST(struct_a, struct_b);\n")),Object(r.b)("h3",{id:"172-functions"},"17.2 Functions"),Object(r.b)("hr",null),Object(r.b)("h4",{id:"1721-substr"},"17.2.1 substr"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* Extract substring of length LEN starting at index POS in a source string, version 1 */\nchar dest[LEN+1];\nstrncpy(dest, &source[POS], LEN);\ndest[LEN] = '\\0'; /* ensure \\0 termination */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'/* Extract substring of length LEN starting at index POS in a source string, version 2 */\nchar dest[LEN+1] = "";\nstrncat(dest, &source[POS], LEN);\n')),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* Extract substring of length LEN starting at index POS in a source string, version 3 */\nchar dest[LEN+1];\nstrncat(dest, source + POS, LEN);\n")),Object(r.b)("h4",{id:"1722-globbing"},"17.2.2 globbing"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* match: match str against pat; return 1 if a match, otherwise 0 */\n/* Example call: match(\"a*b.c\", \"aplomb.c\"), this will return 1 */\nint match(const char *pat, const char *str)\n{\n    switch (*pat)\n    {\n        case '\\0': return !*str;\n        case '*': return match(pat+1, str) || *str && match(pat, str+1);\n        case '?': return *str && match(pat+1, str+1);\n        default: return *pat == *str && match(pat+1, str+1);\n    }\n}\n")),Object(r.b)("h4",{id:"1723-hex_to_int"},"17.2.3 hex_to_int"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'/* hex2int.c: Convert hexadecimal number in any locale */\n/* NOTE: This code does not check for overflow. That requires additional complexity. */\n#include <ctype.h>\n#include <string.h>\n\nint hex_to_int(const char *s)\n{\n    int value;\n    static const char xd[] = {"0123456789abcdefABCDEF"};\n    static const char xv[] =\n    {\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n        10, 11, 12, 13, 14, 15,\n        10, 11, 12, 13, 14, 15\n    };\n\n    for (value = 0; isxdigit(*s); ++s)\n        value = (value << 4) + xv[strchr(xd, *s) - xd];\n    return value;\n}\n')),Object(r.b)("h4",{id:"1724-bit-manipulation-routines"},"17.2.4 Bit Manipulation Routines"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* invert: invert the n bits of x that begin at position p */\nunsigned invert(unsigned x, int p, int n)\n{\n    return x ^ (~(~0 << n) << (p+1-n));\n} /* invert */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* bitcount: count 1 bits in x (assume two's complement number system) */\nint bitcount(unsigned x)\n{\n    int b;\n\n    for (b = 0; x != 0; x &= x-1)\n        ++b;\n    return b;\n} /* bitcount */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* setbits: set n bits of x at position p with rightmost bits of y */\n/* leave all other bits unchanged */\nunsigned setbits(unsigned x, int p, int n, unsigned y)\n{\n    return x & ~(~(~0 << n) << (p+1-n))\n           | (y & ~(~0 << n)) << (p+1-n)\n        ;\n} /* setbits */\n")),Object(r.b)("br",null),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* getbits: get n bits from position p */\nunsigned getbits(unsigned x, int p, int n)\n{\n    return (x >> (p+1-n)) & ~(~0 << n);\n}\n")),Object(r.b)("h4",{id:"1725-miscellaneous-routines"},"17.2.5 Miscellaneous Routines"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"/* escape: copy string t to string s; make newline & tab visible */\nvoid escape(char s[], char t[])\n{\n    int i, j;\n\n    for (i = j = 0; t[i] != '0'; i++)\n        switch (t[i])\n        {\n            case '\\n':\n                s[j++] = '\\\\';\n                s[j++] = 'n';\n                break;\n\n            case '\\t':\n                s[j++] = '\\\\';\n                s[j++] = 't';\n                break;\n            \n            default:\n                s[j++] = t[i];\n                break;\n        }\n    s[j] = '\\0';\n} /* escape */\n")),Object(r.b)("h2",{id:"18-tool-support"},"18 TOOL SUPPORT"),Object(r.b)("p",null,"The best analysis tool is peer review, some kind of informal code\nreview, or formal code inspection. But analysis and metrics tools can\nprovide in-depth analysis of code that those processes can't. What\nfollows are suggestions for such tools."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://smartbear.com/product/collaborator/overview/"}),"Collaborator"),Object(r.b)("br",null),"\nA code review tool which enables reviews to be conducted easily.\nSupports threaded conversations by file and line number. All\nconversations and actions are tracked like newsgroups, and real-time\nweb-based contextual chat is supported."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.doxygen.nl/index.html"}),"Doxygen"),Object(r.b)("br",null),"\nDoxygen is a documentation system which can generate an on-line\ndocumentation browser, extract the code structure from undocumented\nsource files, and create normal documentation."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.imagix.com/products/source-code-analysis.html"}),"Imagix 4D"),Object(r.b)("br",null),"\nHelps software developers comprehend complex or legacy C Code."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.perforce.com/products/helix-qac"}),"QA\xb7C, Programming Research Limited (PRQA)"),Object(r.b)("br",null),"\nAdvanced static analysis for C and C++. Provides bug detection and\ncompliance to coding standards (including MISRA-C:2004). PRQA can create\ncustomer specific compliance modules."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://splint.org/"}),"Splint"),Object(r.b)("br",null),"\nA tool for statically checking C programs for security vulnerabilities and coding mistakes."),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://www.campwoodsw.com/sourcemonitor.html"}),"SourceMonitor"),Object(r.b)("br",null),"\nAnalyses source code and identifies the relative complexity of the modules."),Object(r.b)("h2",{id:"19-tests"},"19 TESTS"),Object(r.b)("p",null,"Guideline: Run Plauger's simple test programs on your implementation to validate the Standard C library implementation."),Object(r.b)("p",null,"Ref ",Object(r.b)("em",{parentName:"p"},"5")," includes simple test programs for each of the Standard C\nLibraries. Each program tests part or all of the facilities provided by\none of the standard headers in the Standard C library. The tests focus\nprimarily on external behaviour, so provide, essentially, a validation\nsuite. Some implementation errors are so common, and pernicious, that\nsome of the programs test internal structure."),Object(r.b)("p",null,"These programs are available to test the Standard C library\nimplementation on your platform, and it is worth using them."),Object(r.b)("h2",{id:"20-c-coding-guidelines"},"20 C CODING GUIDELINES"),Object(r.b)("p",null,"This appendix lists the complete set of guidelines presented in this\ndocument. A hyperlink to the section heading under which each guideline\nappears is provided in square brackets."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Element Header")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Prefix each source file with a template header. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#51-element-header"}),"Source File\nElement Header"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Prefix each header file with a template header. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#51-element-header"}),"Source File\nElement Header"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Prefix each unit with a template header. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#52-unit-header"}),"Unit Header"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Code Layout")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Where present, sections of code should be laid out in the following\norder, prefixed by the comment shown. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#61-module-layout"}),"Module Layout"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Brace and parenthesize using BSD and GNU style. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#62-bracketing"}),"Bracketing"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Separate your control keywords from the following opening bracket. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#63-keywords"}),"Keywords"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Don't separate subroutine or variable names from the following\nopening bracket. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#64-subroutines-and-variables"}),"Subroutines and Variables"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use 78-column lines. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#65-line-lengths"}),"Line Lengths"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use four-column indentation levels. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#66-indentation"}),"Indentation"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Indent with spaces, not tabs. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#67-tabs"}),"Tabs"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Never place two statements on one line. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#68-blocks"}),"Blocks"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Code in paragraphs. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#69-chunking"}),"Chunking"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Corresponding items shall be aligned vertically. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#610-vertical-alignment"}),"Vertical Alignment"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Break long expressions before an operator. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#611-breaking-long-lines"}),"Breaking Long Lines"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Always break a long expression at the operator of the lowest\npossible precedence. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#612-breaking-by-precedence"}),"Breaking by Precedence"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Break long assignments before the assignment operator. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#613-assignments"}),"Assignments"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Enforce your chosen layout style automatically. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#614-automated-layout"}),"Automated Layout"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"C Implementation")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Ensure header files are idempotent. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#71-header-files"}),"Header Files"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not define functions or objects in header files. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#72-header-file-content"}),"Header File Content"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not use the ",Object(r.b)("inlineCode",{parentName:"p"},"goto")," statement. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#73-goto"}),"Goto"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Functions")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Functions should be as short as practicable. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#74-functions"}),"Functions"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use the type-qualifier ",Object(r.b)("inlineCode",{parentName:"p"},"const")," for non-scalar function parameters.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#74-functions"}),"Functions"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Comment the terminating brace of a function with its name. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#74-functions"}),"Functions"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Prefix function names in a separately compiled group of elements with a mnemonic. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#74-functions"}),"Functions"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Null Pointers")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use the ",Object(r.b)("inlineCode",{parentName:"p"},"NULL")," macro instead of 0 in pointer contexts. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#75-null-pointers"}),"The NULL Macro"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A null pointer shall be cast to its correct type when used as an\nargument to a function call. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#752-pointer-arguments"}),"Pointer Arguments"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A function pointer shall not be converted to type ",Object(r.b)("inlineCode",{parentName:"p"},"void\xa0*"),".\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#753-function-pointers"}),"Function Pointers")))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Preprocessor")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"In the definition of a function-like macro each instance of a\nparameter shall be enclosed in parentheses unless it is used as the\noperand of ",Object(r.b)("inlineCode",{parentName:"p"},"#")," or ",Object(r.b)("inlineCode",{parentName:"p"},"##"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#76-preprocessor"}),"Preprocessor"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"C macros shall expand only to a braced initialiser, a constant, a\nparenthesised expression, a type qualifier, a storage class\nspecifier, or a do-while-zero construct. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#76-preprocessor"}),"Preprocessor"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Booleans")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Define pre-processor macros or enumeration constants for true and\nfalse values, which evaluate to 1 and 0. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#772-use-of-true-and-false"}),"Defining TRUE and FALSE"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Only assign TRUE and FALSE to a Boolean variable, never use them in\ncomparisons. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#772-use-of-true-and-false"}),"Defining TRUE and FALSE"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Pointer Declarations")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"When declaring or defining a pointer variable, always ensure there\nis no whitespace between the ",Object(r.b)("inlineCode",{parentName:"li"},"*")," and the identifier. ","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#78-pointer-declarations"}),"Pointer Declarations"),"]")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Naming Conventions")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Name all objects.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"No identifier shall begin with an underscore. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#81-identifiers"}),"Identifiers"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Identifiers (internal and external) and pre-processor macro names\nshall not rely on the significance of more than 31 characters.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#81-identifiers"}),"Identifiers"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use grammatical templates when forming identifiers and function\nnames. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#81-identifiers"}),"Identifiers"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Name Booleans after their associated test. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#82-booleans"}),"Booleans"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Mark variables that store pointers. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#83-pointer-variables"}),"Pointer Variables"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Name arrays in the plural. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#84-arrays"}),"Arrays"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Maintain consistency in the use of multiword identifiers.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#85-multiword-identifiers"}),"Multiword Identifiers"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Abbr idents by prefx. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#86-abbreviations"}),"Abbreviations"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Abbreviate only when the meaning remains unambiguous. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#87-ambiguous-abbreviations"}),"Ambiguous Abbreviations"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Avoid using inherently ambiguous words in names. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#88-ambiguous-names"}),"Ambiguous Names"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use K&R2 style use of case. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#89-general-naming-conventions"}),"General Naming Conventions"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Documentation")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use full-line comments to explain the algorithm. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#91-algorithmic-documentation"}),"Algorithmic Documentation"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use end-of-line comments to point out subtleties and oddities. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#92-elucidating-comments"}),"Elucidating Comments"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Comment anything that has puzzled or tricked you. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#93-defensive-documentation"}),"Defensive Documentation"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Consider whether it's better to rewrite than to comment. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#94-indicative-documentation"}),"Indicative Documentation"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Check the spelling, syntax, and sanity of your documentation. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#95-proofreading"}),"Proofreading"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Library Functions")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use C's Standard Library functions wherever possible.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"assert")," only in development code. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#101-asserth"}),"<assert.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use the functions declared in ",Object(r.b)("inlineCode",{parentName:"p"},"<ctype.h>")," to test or alter\ncharacters that you read in with ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"getc()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"getchar()"),".\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#102-ctypeh"}),"<ctype.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not assume letter codes are adjacent. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1022-letter-codes"}),"Letter Codes"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"errno"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#h3-id103-errnoh-3812103-errnohh3"}),"<errno.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"To avoid overflow, make sure that no value ever exceeds ",Object(r.b)("inlineCode",{parentName:"p"},"DBL_MAX")," in\nmagnitude. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#h3-id104-floath-3780104-floathh3"}),"<float.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"To avoid underflow, make sure that no value ever goes below ",Object(r.b)("inlineCode",{parentName:"p"},"DBL_MIN"),"\nin magnitude. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1042-underflow"}),"Underflow"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Where possible, perform a check when adding a small magnitude to a\nlarge one. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1043-significance-loss"}),"Significance Loss"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Wherever possible, use the macros provided in ",Object(r.b)("inlineCode",{parentName:"p"},"<limits.h>")," to test\nthe execution environment. Do not do experiments on the\npre-processor. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#105-limitsh"}),"<limits.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Be aware of where library behaviour changes with locale.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#106-localeh"}),"<locale.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"setjmp")," or ",Object(r.b)("inlineCode",{parentName:"p"},"longjmp"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#108-setjmph"}),"<setjmp.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"When using the macros in ",Object(r.b)("inlineCode",{parentName:"p"},"<stdarg.h>")," be aware of the caveats listed\nin this Guideline. ","[","You must declare a function explicitly as\nhaving a variable argument list, (call it f). Its argument list must\nend in ellipsis (, ...), both in its definition and any\ndeclarations. ","[","<stdarg.h",">","](#1010-stdargh)","]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"size_t")," ",Object(r.b)("em",{parentName:"p"},"anywhere")," your program performs array subscripting or\naddress arithmetic. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1011-stddefh"}),"<stddef.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Function ",Object(r.b)("inlineCode",{parentName:"p"},"gets")," shall not be used. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10121-gets"}),"gets"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"getc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fgetc"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10121-gets"}),"getc"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"putc")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"fputc"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10123-putc"}),"putc"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Call ",Object(r.b)("inlineCode",{parentName:"p"},"fread")," in a way such that it can report how many additional\ncharacters it read (if any). ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10124-fread"}),"fread"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Always use ",Object(r.b)("inlineCode",{parentName:"p"},"remove")," to remove any files you created with ",Object(r.b)("inlineCode",{parentName:"p"},"tmpnam"),".\n","[","remove](#10125-remove)","]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Always check the return value of ",Object(r.b)("inlineCode",{parentName:"p"},"rename "),"to see if the operation\nsucceeded. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10126-rename"}),"rename"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"rewind"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10127-rewind"}),"rewind"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"setvbuf")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"setbuf"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10128-setbuf"}),"setbuf"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"tmpfile")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"tmpnam")," wherever possible. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10129-tmpfile"}),"tmpfile"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Gather related data into a structure and allocate it all at once. Do\n",Object(r.b)("em",{parentName:"p"},"not")," gather unrelated data just to save heap overhead.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#h3-id1013-stdlibh-33051013-stdlibhh3"}),"<stdlib.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Allocate data objects with similar lifetimes all at once, then free\nthem at about the same time. Do ",Object(r.b)("em",{parentName:"p"},"not")," advance or defer unrelated\nheap operations just to minimize fragmentation. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#h3-id1013-stdlibh-33141013-stdlibhh3"}),"<stdlib.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"EXIT_FAILURE")," and ",Object(r.b)("inlineCode",{parentName:"p"},"EXIT SUCCESS")," as the argument to exit or the\nreturn value from main to report unsuccessful and successful program\ntermination. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10132-exit_failure-and-exit-success"}),"EXIT_FAILURE and EXIT SUCCESS"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Wherever possible, call ",Object(r.b)("inlineCode",{parentName:"p"},"exit(EXIT_FAILURE)")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"abort"),".\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10133-abort"}),"abort"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Call ",Object(r.b)("inlineCode",{parentName:"p"},"abs(x)")," instead of writing the idiom ",Object(r.b)("inlineCode",{parentName:"p"},"x < 0 ? --x : x"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10134-abs"}),"abs"),"]","    ")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"strtod")," instead of ",Object(r.b)("inlineCode",{parentName:"p"},"atof"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10135-atof"}),"atof"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not use ",Object(r.b)("inlineCode",{parentName:"p"},"calloc")," to initialise floating-point values to zeros, or\npointers to null pointers. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10136-calloc"}),"calloc"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Do not assume the product of ",Object(r.b)("inlineCode",{parentName:"p"},"calloc"),"'s arguments is all that matters.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#10136-calloc"}),"calloc"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"If a string can contain null characters, specify its length and use\nfunctions whose names begin with ",Object(r.b)("inlineCode",{parentName:"p"},"mem"),". ","[","<string.h",">","](#1014-stringh)","]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use ",Object(r.b)("inlineCode",{parentName:"p"},"memmove")," to copy a string if the source and destination strings\nmight overlap. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1014-stringh"}),"<string.h",">"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"If a string may or may not have a terminating null character,\nspecify its maximum length and use the functions beginning with\n",Object(r.b)("inlineCode",{parentName:"p"},"strn"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#1014-stringh"}),"<string.h",">"),"]"))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If a string definitely has a terminating null character, specify\nonly the string and use the remaining functions whose names begin\nwith ",Object(r.b)("inlineCode",{parentName:"li"},"str"),". ","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#1014-stringh"}),"<string.h",">"),"]")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Use ",Object(r.b)("inlineCode",{parentName:"li"},"strcat")," if you have only two strings to concatenate, or just a\nfew short strings. Otherwise use strcpy. ","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#1014-stringh"}),"<string.h",">"),"]")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Always copy the value returned by a call to another (or the same)\nfunction if you need the value beyond a conflicting function call.\n","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#1015-timeh"}),"<time.h",">"),"]")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"SUPPORT LIBRARIES")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If Glasswall Solutions Limited has a library of support routines\nthat have been reviewed, debugged and tested, and released for use,\nthen those routines should be used rather than a developer writing\nhis or her own routines to achieve the same functionality. ","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#11-support-libraries"}),"Support Libraries"),"]")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Error Handling")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If a function returns error information, then that error information\nshall be tested. ","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#121-function"}),"Function"),"]")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Values and Expressions")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Don't use octal constants (except zero) and octal escape sequences.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#131-leading-zeros"}),"Leading Zeros"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Lay out multiline strings over multiple lines. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#132-multiline-strings"}),"Multiline Strings"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Don't use commas to sequence statements. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#133-comma-operator"}),"Comma Operator"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Use symbolic constants to give numbers meaningful names.\n","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#134-constants"}),"Constants")))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Variables")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Avoid using global variables. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#141-global-variables"}),"Global Variables"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Initialise all automatic variables. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#142-initialisation"}),"Initialisation"),"]")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Declare data objects within functions at the innermost possible\nnesting level. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#143-scope"}),"Scope"),"]"))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Control Structures")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Reject as many iterations as possible, as early as possible.\n","[",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#151-linear-coding"}),"Linear Coding"),"]")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Undefined Behaviours")),Object(r.b)("p",null,"The Undefined Behaviours section lists many guidelines in the form of\nexplicatory paragraphs; therefore, they are not reproduced here. ","[",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#16-undefined-behaviours"}),"Undefined Behaviours"),"]"))}s.isMDXComponent=!0},234:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var b=i.a.createContext({}),s=function(e){var t=i.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return i.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=s(n),u=a,m=p["".concat(o,".").concat(u)]||p[u]||d[u]||r;return n?i.a.createElement(m,l(l({ref:t},b),{},{components:n})):i.a.createElement(m,l({ref:t},b))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var b=2;b<r;b++)o[b]=n[b];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);