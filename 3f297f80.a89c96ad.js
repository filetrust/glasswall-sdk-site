(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),b=(n(0),n(236)),c={title:"Structured Storage API Specification"},o={unversionedId:"2-glasswall_core/artifacts/structured_storage_api_specification",id:"2-glasswall_core/artifacts/structured_storage_api_specification",isDocsHomePage:!1,title:"Structured Storage API Specification",description:"&copy; 2014 Glasswall Solutions Limited",source:"@site/docs/2-glasswall_core/artifacts/structured_storage_api_specification.md",slug:"/2-glasswall_core/artifacts/structured_storage_api_specification",permalink:"/glasswall-sdk-site/docs/2-glasswall_core/artifacts/structured_storage_api_specification",version:"current",sidebar:"someSidebar",previous:{title:"Additional Features",permalink:"/glasswall-sdk-site/docs/2-glasswall_core/artifacts/glasswall_features"},next:{title:"BDDL Guidelines",permalink:"/glasswall-sdk-site/docs/artifacts/BddlDeveloperGuidelines"}},s=[{value:"<strong>2.1 Objective</strong>",id:"21-objective",children:[]},{value:"<strong>2.2 Nomenclature</strong>",id:"22-nomenclature",children:[]},{value:"<strong>2.3 Structured Storage</strong>",id:"23-structured-storage",children:[]},{value:"<strong>2.4 Types</strong>",id:"24-types",children:[]},{value:"<strong>3.1 The deleteDescendants Function</strong>",id:"31-the-deletedescendants-function",children:[]},{value:"<strong>3.2 The deleteStream Function</strong>",id:"32-the-deletestream-function",children:[]},{value:"<strong>3.3 The deleteTree Function</strong>",id:"33-the-deletetree-function",children:[]},{value:"<strong>3.4 The getCLSID Function</strong>",id:"34-the-getclsid-function",children:[]},{value:"<strong>3.5 The getFirstChild Function</strong>",id:"35-the-getfirstchild-function",children:[]},{value:"<strong>3.6 The getName Function</strong>",id:"36-the-getname-function",children:[]},{value:"<strong>3.7 The getNextChild Function</strong>",id:"37-the-getnextchild-function",children:[]},{value:"<strong>3.8 The getObjectRule Function</strong>",id:"38-the-getobjectrule-function",children:[]},{value:"<strong>3.9 The getObjectTag Function</strong>",id:"39-the-getobjecttag-function",children:[]},{value:"<strong>3.10 The getObjectType Function</strong>",id:"310-the-getobjecttype-function",children:[]},{value:"<strong>3.11 The getStreamPtr Function</strong>",id:"311-the-getstreamptr-function",children:[]},{value:"<strong>3.12 The getStreamSize Function</strong>",id:"312-the-getstreamsize-function",children:[]},{value:"<strong>3.13 The getStructuredStorageSize Function</strong>",id:"313-the-getstructuredstoragesize-function",children:[]},{value:"<strong>3.14 The initialiseAdaptor Function</strong>",id:"314-the-initialiseadaptor-function",children:[]},{value:"<strong>3.15 Function isNextChild</strong>",id:"315-function-isnextchild",children:[]},{value:"<strong>3.16 The isValidObjectType Function</strong>",id:"316-the-isvalidobjecttype-function",children:[]},{value:"<strong>3.17 The loadStream Function</strong>",id:"317-the-loadstream-function",children:[]},{value:"<strong>3.18 The saveDocument Function</strong>",id:"318-the-savedocument-function",children:[]},{value:"<strong>3.19 The setStreamPtr Function</strong>",id:"319-the-setstreamptr-function",children:[]},{value:"<strong>3.20 The setStreamSize Function</strong>",id:"320-the-setstreamsize-function",children:[]},{value:"<strong>3.21 The setObjectRule Function</strong>",id:"321-the-setobjectrule-function",children:[]},{value:"<strong>3.22 The uninitialiseAdaptor Function</strong>",id:"322-the-uninitialiseadaptor-function",children:[]},{value:"<strong>4.1 Navigating through a tree from root</strong>",id:"41-navigating-through-a-tree-from-root",children:[]}],i={rightToc:s};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(b.b)("wrapper",Object(a.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(b.b)("div",{style:{textAlign:"center"}},Object(b.b)("p",null,"\xa9"," 2014 Glasswall Solutions Limited",Object(b.b)("br",null),"\nALL RIGHTS RESERVED"),Object(b.b)("p",null,"Information contained herein is the property of Glasswall Solutions Limited and is proprietary and confidential."),Object(b.b)("p",null,"Martin O\u2019Brien",Object(b.b)("br",null),"\nGlasswall Solutions Limited",Object(b.b)("br",null),"\n",Object(b.b)("a",Object(a.a)({parentName:"p"},{href:"mailto:mobrien@glasswallsolutions.co.uk"}),"mobrien@glasswallsolutions.co.uk"),Object(b.b)("br",null))),Object(b.b)("ul",null,Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#1-glossary"}),Object(b.b)("strong",{parentName:"a"},"1 GLOSSARY"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#2-introduction"}),Object(b.b)("strong",{parentName:"a"},"2 INTRODUCTION")),Object(b.b)("ul",{parentName:"li"},Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#21-objective"}),Object(b.b)("strong",{parentName:"a"},"2.1 Objective"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#h2-id22-nomenclature-150622-nomenclatureh2"}),"## ",Object(b.b)("strong",{parentName:"a"},"2.2 Nomenclature"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#23-structured-storage"}),Object(b.b)("strong",{parentName:"a"},"2.3 Structured Storage"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#24-types"}),Object(b.b)("strong",{parentName:"a"},"2.4 Types"))))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#3-api-functions"}),Object(b.b)("strong",{parentName:"a"},"3 API Functions")),Object(b.b)("ul",{parentName:"li"},Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#31-the-deletedescendants-function"}),Object(b.b)("strong",{parentName:"a"},"3.1 The deleteDescendants Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#32-the-deletestream-function"}),Object(b.b)("strong",{parentName:"a"},"3.2 The deleteStream Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#33-the-deletetree-function"}),Object(b.b)("strong",{parentName:"a"},"3.3 The deleteTree Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#34-the-getclsid-function"}),Object(b.b)("strong",{parentName:"a"},"3.4 The getCLSID Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#35-the-getfirstchild-function"}),Object(b.b)("strong",{parentName:"a"},"3.5 The getFirstChild Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#h2-id36-the-getname-function-136636-the-getname-functionh2"}),"## ",Object(b.b)("strong",{parentName:"a"},"3.6 The getName Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#37-the-getnextchild-function"}),Object(b.b)("strong",{parentName:"a"},"3.7 The getNextChild Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#38-the-getobjectrule-function"}),Object(b.b)("strong",{parentName:"a"},"3.8 The getObjectRule Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#39-the-getobjecttag-function"}),Object(b.b)("strong",{parentName:"a"},"3.9 The getObjectTag Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#310-the-getobjecttype-function"}),Object(b.b)("strong",{parentName:"a"},"3.10 The getObjectType Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#311-the-getstreamptr-function"}),Object(b.b)("strong",{parentName:"a"},"3.11 The getStreamPtr Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#312-the-getstreamsize-function"}),Object(b.b)("strong",{parentName:"a"},"3.12 The getStreamSize Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#313-the-getstructuredstoragesize-function"}),Object(b.b)("strong",{parentName:"a"},"3.13 The getStructuredStorageSize Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#314-the-initialiseadaptor-function"}),Object(b.b)("strong",{parentName:"a"},"3.14 The initialiseAdaptor Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#315-function-isnextchild"}),Object(b.b)("strong",{parentName:"a"},"3.15 Function isNextChild"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#316-the-isvalidobjecttype-function"}),Object(b.b)("strong",{parentName:"a"},"3.16 The isValidObjectType Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#317-the-loadstream-function"}),Object(b.b)("strong",{parentName:"a"},"3.17 The loadStream Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#318-the-savedocument-function"}),Object(b.b)("strong",{parentName:"a"},"3.18 The saveDocument Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#319-the-setstreamptr-function"}),Object(b.b)("strong",{parentName:"a"},"3.19 The setStreamPtr Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#320-the-setstreamsize-function"}),Object(b.b)("strong",{parentName:"a"},"3.20 The setStreamSize Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#321-the-setobjectrule-function"}),Object(b.b)("strong",{parentName:"a"},"3.21 The setObjectRule Function"))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#322-the-uninitialiseadaptor-function"}),Object(b.b)("strong",{parentName:"a"},"3.22 The uninitialiseAdaptor Function"))))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#4-example-usage"}),Object(b.b)("strong",{parentName:"a"},"4 EXAMPLE USAGE")),Object(b.b)("ul",{parentName:"li"},Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#41-navigating-through-a-tree-from-root"}),Object(b.b)("strong",{parentName:"a"},"4.1 Navigating through a tree from root"))))),Object(b.b)("li",{parentName:"ul"},Object(b.b)("a",Object(a.a)({parentName:"li"},{href:"#5-summary-of-api-functions"}),Object(b.b)("strong",{parentName:"a"},"5 Summary of API Functions")))),Object(b.b)("h1",{id:"1-glossary"},Object(b.b)("strong",{parentName:"h1"},"1 GLOSSARY")),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",Object(a.a)({parentName:"tr"},{align:null}),Object(b.b)("strong",{parentName:"th"},"Term")),Object(b.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"> ",Object(b.b)("strong",{parentName:"th"},"Description")))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Child"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"This refers to the child of a particular storage object or root object. Only one child is stored in a storage or root object; other children are linked by the sibling connection of that child and the sibling connections of those siblings.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Children"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"The children of the root object or any storage object are determined by the single child link of that root or storage object, and all the storages and  streams are linked together in the sibling list.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Descendants"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"The descendants of a particular storage or root object are all the children and their children ",Object(b.b)("em",{parentName:"td"},"ad infinitum"),".")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Directory Entry"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An object that contains a storage object's or stream object's FileInformation.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"FileInformation"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Information that is maintained about a file.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Object Rule"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An object rule is a structure containing information required to process a storage object or stream object. It contains pointers to functions that will process a stream, and also contains pointers to pre- and post-storage handler functions. It contains the object tag, used to uniquely identify the rule.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Object Tag"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An unsigned value that uniquely identifies an object rule. It is used by the rules processor to match rules.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Parent"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"This refers to the storage that has this node as its child.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Root storage object"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"A root storage object in a compound file that must be accessed before any other storage objects and stream objects are referenced. It is the uppermost parent object in the storage object and stream object hierarchy. A root storage object will have an Object Type of type ObjectType_t with value ROOT_OBJECT_TYPE.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Sibling"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"For a storage object or stream object, a sibling of that object is another storage object or stream object that has the same parent.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Storage object"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An object in a compound file analogous to a file system  directory. The parent object of a storage object must be another storage object or the root   storage object. The word ",Object(b.b)("em",{parentName:"td"},"storage")," is used in this document to include the root storage object, unless the root storage object is specifically indicated. A storage object will have an Object Type of type ObjectType_t with value STORAGE_OBJECT_TYPE.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Stream ID"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An unsigned value which identifies a particular stream object, storage object, or root storage object. The value 0 is reserved for the root storage  object of the directory structure. Each stream ID must be unique across all the streams and storages in a file.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Stream object"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"An object analogous to a file system file. The parent object of a stream object must be a storage object or the root storage object. A stream object will have an Object Type of type ObjectType_t with value STREAM_OBJECT_TYPE.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Structured Storage"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"A single file containing a structured collection of objects known as storages and streams. The implementation of such a structure.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Unknown or Unallocated object"),Object(b.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Some objects will have an Object Type of UNKNOWN_OR_UNALLOCATED_OBJECT_TYPE. This is a valid object type and usually indicates an uninitialised object.")))),Object(b.b)("h1",{id:"2-introduction"},Object(b.b)("strong",{parentName:"h1"},"2 INTRODUCTION")),Object(b.b)("h2",{id:"21-objective"},Object(b.b)("strong",{parentName:"h2"},"2.1 Objective")),Object(b.b)("p",null,"The objective of this document is to provide a general interface to clients that will want to process difference document types in the Glasswall software. It aims to provide consistent naming across APIs for all cameras. "),Object(b.b)("h2",{id:"22-nomenclature"},Object(b.b)("strong",{parentName:"h2"},"2.2 Nomenclature")),Object(b.b)("hr",null),Object(b.b)("p",null,"Lucida Console is used for any source code related information. This is\nto distinguish it from normal text, and to obviate problems in other\nfonts for reading names such as"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"lInfoFlag1")),Object(b.b)("p",null,"which is actually"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"lInfoFlag1")),Object(b.b)("p",null,"(lowercase L and uppercase i look the some in quite a few fonts).\nCourier would have served just as well:"),Object(b.b)("blockquote",null,Object(b.b)("p",{parentName:"blockquote"},"lInfoFlag1")),Object(b.b)("p",null,"Depending on context, the word ",Object(b.b)("em",{parentName:"p"},"bracket")," is used to indicate any of the\npaired delimiters (), {}, ","[","]","."),Object(b.b)("p",null,"Code examples are generally shown in a box with a grey background, using\nLucinda Console font. Sometimes short examples are included in the text\nin a monospaced font."),Object(b.b)("h2",{id:"23-structured-storage"},Object(b.b)("strong",{parentName:"h2"},"2.3 Structured Storage")),Object(b.b)("p",null,"The API is designed to provide an interface to any type of document. The\nclient creates a set of functions that understands the document format\nand those functions are mapped to the API function pointer names by the\nclient code. Thus, client functions ",Object(b.b)("strong",{parentName:"p"},"cfbGetName")," and ",Object(b.b)("strong",{parentName:"p"},"opcGetName"),"\nwill be mapped to via a call to ",Object(b.b)("strong",{parentName:"p"},"getName"),"."),Object(b.b)("p",null,"When a file is opened by a call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),", the actual\nfunction called will ensure that the file is read in and placed in the\nsame type of structured storage whatever the underlying file type is.\nThus a binary Excel file, or an OPC Excel file, will be converted into\nthis structured storage."),Object(b.b)("p",null,"Structured storage is modelled after a file system which contains a\nnested hierarchy of ",Object(b.b)("strong",{parentName:"p"},"stream objects")," and ",Object(b.b)("strong",{parentName:"p"},"storage objects"),". A\nstreams object is analogous to a file, and a storage object is analogous\nto a directory, which means storage objects can contain other storage\nobjects and stream objects."),Object(b.b)("p",null,"The hierarchy is defined by a parent object/child object relationship.\nStream objects can not contain child objects. Storage objects can\ncontain other storage objects and stream objects."),Object(b.b)("p",null,"At the top of the hierarchy is a ",Object(b.b)("strong",{parentName:"p"},"root storage object")," which has no\nparent object. The root storage object is not part of the original file\nbut is used to navigate the structured storage."),Object(b.b)("p",null,"An ",Object(b.b)("strong",{parentName:"p"},"object type")," is used to identify an object as a storage object\n(1), a stream object (2), or a root storage object (5). 0 is used to\ndenote an unknown or unallocated object."),Object(b.b)("p",null,"Each stream object or storage object is identified by a non-negative\ninteger referred to as a ",Object(b.b)("strong",{parentName:"p"},"Stream ID"),". The root storage object, named\n",Object(b.b)("strong",{parentName:"p"},"Root Entry")," will always have stream ID 0."),Object(b.b)("p",null,"Use of all the API functions is predicated on a successful call to\n",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),". This function accepts the name of the file to\nopen and creates the structured storage in memory, ready to be accessed\nvia the other API calls. ",Object(b.b)("strong",{parentName:"p"},"uninitialiseAdaptor")," must be called to clear\nthe structured storage."),Object(b.b)("h2",{id:"24-types"},Object(b.b)("strong",{parentName:"h2"},"2.4 Types")),Object(b.b)("p",null,"The API makes available an enumeration for use by clients:"),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"ObjectType_t\n")),Object(b.b)("p",null,"which contains the following constants:"),Object(b.b)("hr",null),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"UNKNOWN_OR_UNALLOCATED_OBJECT_TYPE\n")),Object(b.b)("p",null,"This indicates that the object has been uninitialised and is not used."),Object(b.b)("hr",null),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"STORAGE_OBJECT_TYPE\n")),Object(b.b)("p",null,"This indicates the object is a storage object.  "),Object(b.b)("hr",null),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"STREAM_OBJECT_TYPE\n")),Object(b.b)("p",null,"This indicates the object is a stream object"),Object(b.b)("hr",null),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"ROOT_OBJECT_TYPE\n")),Object(b.b)("p",null,"This indicates the object is a root storage object."),Object(b.b)("hr",null),Object(b.b)("h1",{id:"3-api-functions"},Object(b.b)("strong",{parentName:"h1"},"3 API Functions")),Object(b.b)("h2",{id:"31-the-deletedescendants-function"},Object(b.b)("strong",{parentName:"h2"},"3.1 The deleteDescendants Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus deleteDescendants(StreamID_t streamID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"deleteDescendants")," function deletes the descendants of the\nstorage object with stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"deleteDescendants")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),";\nif a successful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamID")," refers to a stream object\n(i.e., not a root object or storage object), the ",Object(b.b)("strong",{parentName:"p"},"deleteDescendants"),"\nfunction returns ",Object(b.b)("strong",{parentName:"p"},"FAIL.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (deleteDescendants(streamID) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing; streamID still refers to an existing storage\n*/\n')),Object(b.b)("h2",{id:"32-the-deletestream-function"},Object(b.b)("strong",{parentName:"h2"},"3.2 The deleteStream Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus deleteStream(StreamID_t streamID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"deleteStream")," function deletes the stream object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"streamID.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"deleteStream")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamID")," refers to a non-stream object,\nthe ",Object(b.b)("strong",{parentName:"p"},"deleteStream")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (deleteStream(streamID) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing; streamID is no longer valid */\n')),Object(b.b)("h2",{id:"33-the-deletetree-function"},Object(b.b)("strong",{parentName:"h2"},"3.3 The deleteTree Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus deleteTree(StreamID_t streamID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"deleteTree")," function deletes the storage object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"streamID")," and all its descendants."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"deleteTree")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamID")," refers to a stream object\n(i.e., not storage object), or there is no storage object with a stream\nID of ",Object(b.b)("strong",{parentName:"p"},"streamID"),", or ",Object(b.b)("strong",{parentName:"p"},"streamID")," refers to the root storage object,\nthe ",Object(b.b)("strong",{parentName:"p"},"deleteTree")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (deleteTree(streamID) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing; the storage specified by streamID no longer\nexists */\n')),Object(b.b)("h2",{id:"34-the-getclsid-function"},Object(b.b)("strong",{parentName:"h2"},"3.4 The getCLSID Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getCLSID(StreamID_t streamID, CLSID_t \\*classID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getCLSID")," function stores the object class GUID of the stream\nwith stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID")," in the object pointed to by ",Object(b.b)("strong",{parentName:"p"},"classID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getCLSID")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"classID")," is NULL, or an object class GUID\nis not part of the underlying structure, the ",Object(b.b)("strong",{parentName:"p"},"getCLSID")," function\nreturns ",Object(b.b)("strong",{parentName:"p"},"FAIL.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\nCLSID_t clsID;\n/* initialise parentID */\n. . .\nif (getCLSID(streamID, &clsID) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using clsID */\n')),Object(b.b)("h2",{id:"35-the-getfirstchild-function"},Object(b.b)("strong",{parentName:"h2"},"3.5 The getFirstChild Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getFirstChild(StreamID_t parentStreamID, StreamID_t\n*firstChildID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getFirstChild")," function stores in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"firstChildID")," the child stream ID in the object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"parentStreamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getFirstChild")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"parentStreamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"firstChildID")," is NULL, the\n",Object(b.b)("strong",{parentName:"p"},"getFirstChild")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL.")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t parentStreamID;\nStreamID_t firstChildID;\n   /* initialise parentStreamID */\n. . .\n/* now get the child ID of parentStreamID */\nif (getFirstChildID(parentStreamID, &firstChildID) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using firstChildID */\n')),Object(b.b)("h2",{id:"36-the-getname-function"},Object(b.b)("strong",{parentName:"h2"},"3.6 The getName Function")),Object(b.b)("hr",null),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getName(StreamID_t streamID, String \\*name);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getName")," function stores the pointer to the name in the stream\nwith stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID")," into the object pointed to by ",Object(b.b)("strong",{parentName:"p"},"name"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getName")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"name")," is NULL, the ",Object(b.b)("strong",{parentName:"p"},"getName")," function\nreturns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t parentStreamID;\nStreamID_t firstChildID;\nString name;\n/* initialise parentStreamID */\n. . .\nif (getName(parentStreamID, &name) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using name */\n')),Object(b.b)("h2",{id:"37-the-getnextchild-function"},Object(b.b)("strong",{parentName:"h2"},"3.7 The getNextChild Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getNextChild(StreamID_t parentStreamID, StreamID_t prevChildID StreamID_t *nextChildID);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getNextChild")," function stores in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"nextChildID")," the stream ID of the next stream it finds after\n",Object(b.b)("strong",{parentName:"p"},"prevChildID")," that has ",Object(b.b)("strong",{parentName:"p"},"parentStreamID")," as a parent."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getNextChild")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"prevChildID")," or ",Object(b.b)("strong",{parentName:"p"},"parentStreamID")," are invalid, or ",Object(b.b)("strong",{parentName:"p"},"nextChildID")," is\nNULL, the ",Object(b.b)("strong",{parentName:"p"},"getNextChild")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t parentStreamID;\nStreamID_t firstChildID, nextChildID;\nif (getFirstChild(ROOT_ENTRY, &firstChildID) != SUCCESS)\n. . .\nelse if (getNextChild(ROOT_ENTRY, firstChildID, &nextChildID) !=\nSUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using firstChildID */\n')),Object(b.b)("h2",{id:"38-the-getobjectrule-function"},Object(b.b)("strong",{parentName:"h2"},"3.8 The getObjectRule Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getObjectRule(StreamID_t streamID, ObjectRule_t **pObjectRule);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getObjectRule")," function stores a pointer to the rule, of the\nobject with stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID,")," in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"pObjectRule"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getObjectRule")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"pObjectRule")," is NULL, the\n",Object(b.b)("strong",{parentName:"p"},"getObjectRule")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nObjectRule_t *pObjectRule;\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (getObjectRule(streamID, &objectRule) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing */\n')),Object(b.b)("h2",{id:"39-the-getobjecttag-function"},Object(b.b)("strong",{parentName:"h2"},"3.9 The getObjectTag Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getObjectTag(StreamID_t streamID, ObjectTag_t *objectTag);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getObjectTag")," function stores in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"objectTag")," the object tag specified by ",Object(b.b)("strong",{parentName:"p"},"streamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getObjectTag")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"objectTag")," is NULL, the ",Object(b.b)("strong",{parentName:"p"},"getObjectTag"),"\nfunction returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nObjectTag_t objectTag;\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (getObjectTag(streamID, &objecttag) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using objectTag */\n')),Object(b.b)("h2",{id:"310-the-getobjecttype-function"},Object(b.b)("strong",{parentName:"h2"},"3.10 The getObjectType Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getObjectType(StreamID_t streamID, ObjectType_t *objectType);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getObjectType")," function stores the object type of the stream with\nstream ID ",Object(b.b)("strong",{parentName:"p"},"streamID")," into the object pointed to by ",Object(b.b)("strong",{parentName:"p"},"objectType"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getObjectType")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"objectType")," is NULL, the\n",Object(b.b)("strong",{parentName:"p"},"getObjectType")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\n/* initialise streamID */\n. . .\nif (getObjectType(streamID, &objectType) != SUCCESS)\n    /* deal with error */\nelse\n{\n    switch (objectType)\n        {\n        case ROOT_OBJECT_TYPE:    /* ... process root storage ... */\n            break;\n        case STORAGE_OBJECT_TYPE: /* ... process non-root storage ... */\n            break;\n        case STREAM_OBJECT_TYPE:  /* ... process a stream ... */\n            break;\n        case UNKNOWN_OR_UNALLOCATED_OBJECT_TYPE /* might be empty directory entry */\n            break;\n        default:\n           /* .. . deal with an invalid object type ... */\n            break;\n        }\n}\n')),Object(b.b)("h2",{id:"311-the-getstreamptr-function"},Object(b.b)("strong",{parentName:"h2"},"3.11 The getStreamPtr Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getStreamPtr(StreamID_t streamID, memoryBuffer \\*\\*streamPtr);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getStreamPtr")," function stores in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"streamPtr")," a pointer to the same ",Object(b.b)("strong",{parentName:"p"},"memoryBuffer")," pointed to by the\n",Object(b.b)("strong",{parentName:"p"},"streamData")," member of the stream object with stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getStreamPtr")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamPtr")," is NULL, the ",Object(b.b)("strong",{parentName:"p"},"getStreamPtr"),"\nfunction returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\nmemoryBuffer \\*inBuf = NULL;\n/* initialise streamID */\n. . .\nif (getStreamPtr(streamID, &inBuf) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using inBuf */\n')),Object(b.b)("h2",{id:"312-the-getstreamsize-function"},Object(b.b)("strong",{parentName:"h2"},"3.12 The getStreamSize Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getStreamSize(StreamID_t streamID, StreamSize_t \\*pStreamSize);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getStreamSize")," function stores the size of the stream with stream\nID ",Object(b.b)("strong",{parentName:"p"},"streamID")," in the object pointed to by ",Object(b.b)("strong",{parentName:"p"},"pStreamSize"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getStreamSize")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamSize")," is NULL, or ",Object(b.b)("strong",{parentName:"p"},"streamID"),"\nrefers to a stream marked as deleted, the ",Object(b.b)("strong",{parentName:"p"},"getStreamSize")," function\nreturns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\nStreamSize_t streamSize;\n/* initialise streamID */\n. . .\nif (getStreamSize(streamID, &streamSize) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using streamSize */\n')),Object(b.b)("h2",{id:"313-the-getstructuredstoragesize-function"},Object(b.b)("strong",{parentName:"h2"},"3.13 The getStructuredStorageSize Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus getStructuredStorageSize(size_t \\*pSize);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"getStructureStorageSize")," function stores a count of all the\nobjects in the structured storage in the object pointed to by ",Object(b.b)("strong",{parentName:"p"},"pSize"),".\nThe count includes the Root Storage object."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"getStructureStorageSize")," function returns\n",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a successful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been\nmade, or p",Object(b.b)("strong",{parentName:"p"},"Size")," is NULL, the ",Object(b.b)("strong",{parentName:"p"},"getStructureStorageSize")," function\nreturns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nsize_t size;\nif (initialiseAdaptor(&inBuf, &outBuf) != SUCCESS)\n   /* deal with error */\nelse if (getStructuredStorageSize(&size) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing using size */\n')),Object(b.b)("h2",{id:"314-the-initialiseadaptor-function"},Object(b.b)("strong",{parentName:"h2"},"3.14 The initialiseAdaptor Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus initialiseAdaptor(memoryBuffer \\*inBuf, memoryBuffer \\*outBuf);\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Description")),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," function creates a structured storage\nrepresentation using information in the structure pointed to by\n",Object(b.b)("strong",{parentName:"p"},"inBuf"),". ",Object(b.b)("strong",{parentName:"p"},"outBuf")," points to a memory buffer structure that will be\nused by other Adaptor API functions. All subsequent calls to the Adaptor\nAPI functions will FAIL unless this function has been called\nsuccessfully."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),";\nif ",Object(b.b)("strong",{parentName:"p"},"inBuf")," is NULL, or the adaptor has already been initialised, the\n",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nif (initialiseAdaptor(&inBuf, &outBuf) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing */\n')),Object(b.b)("h2",{id:"315-function-isnextchild"},Object(b.b)("strong",{parentName:"h2"},"3.15 Function isNextChild")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nBool isNextChild(streamID_t parentStreamID, StreamID_t prevChildID);\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Description")),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"isNextChild")," function determines whether there is another sibling\nafter the sibling ",Object(b.b)("strong",{parentName:"p"},"prevChildID")," with parent ",Object(b.b)("strong",{parentName:"p"},"parentStreamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If there is another sibling, the ",Object(b.b)("strong",{parentName:"p"},"isNextChild")," function returns a\nnonzero value to indicate true; if there is not another sibling the\n",Object(b.b)("strong",{parentName:"p"},"isNextChild")," function returns 0 to indicate false."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),". . .\nwhile (isNextSibling(parentID, prevChildID)\n{\n    if (getNextChild(parentID, prevChildID, &childID) != SUCCESS)\n        . . . deal with error . . .\n    else\n    {\n        . . . process childID . . .\n        prevChildID = childID;\n\n    }\n}\n")),Object(b.b)("h2",{id:"316-the-isvalidobjecttype-function"},Object(b.b)("strong",{parentName:"h2"},"3.16 The isValidObjectType Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nBool isValidObjectType(ObjectType_t objectType);\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Description")),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"isValidObjectType")," function tests that ",Object(b.b)("strong",{parentName:"p"},"objectType")," is one of\nthe values in the enumeration ObjectType_t:\nUNKNOWN_OR_UNALLOCATED_OBJECT, STORAGE_OBJECT_TYPE, STREAM_OBJECT_TYPE,\nor ROOT_OBJECT_TYPE."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If ",Object(b.b)("strong",{parentName:"p"},"objectType")," is one of the values 0, 1, 2, or 5\n",Object(b.b)("strong",{parentName:"p"},"isValidObjectType")," returns a nonzero value to indicate true;\notherwise, it returns zero to indicate false."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStreamID_t streamID;\nObjectType_t objectType;\n. . . initialise streamID ...\nif (getObjectType(streamID, &objectType) != SUCCESS)\n   /* deal with error */\nelse if (isValidObjectType(objectType))\n   /* continue using objectType */\nelse\n   /* deal with error */\n')),Object(b.b)("h2",{id:"317-the-loadstream-function"},Object(b.b)("strong",{parentName:"h2"},"3.17 The loadStream Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus loadStream(StreamID_t streamID, memoryBuffer \\*\\*stream);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"loadStream")," function will allocate a memory buffer large enough\nto hold the stream data referenced by the stream object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"streamID"),". ",Object(b.b)("strong",{parentName:"p"},"loadStream")," will store in the object pointed to by\n",Object(b.b)("strong",{parentName:"p"},"stream")," the pointer to that newly created buffer and will store that\nsame pointer in the relevant field of the stream object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"streamID"),". This means that after a successful call, the client can\naccess the stream directly through the second argument."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"loadStream")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"stream")," is NULL, or ",Object(b.b)("strong",{parentName:"p"},"streamID")," refers\nto a non-stream object, the ",Object(b.b)("strong",{parentName:"p"},"loadStream")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamID_t streamID;\nmemoryBuffer *streamPtr = NULL;\nif ((status = loadStream(streamID, &streamPtr) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing */\n')),Object(b.b)("h2",{id:"318-the-savedocument-function"},Object(b.b)("strong",{parentName:"h2"},"3.18 The saveDocument Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus saveDocument(void);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"saveDocument")," function saves the structured storage\nrepresentation of the archive created by a previous call to\n",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),". The method and target for the save is specific to\nthe type of file represented by the structured storage."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"saveDocument")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, the\n",Object(b.b)("strong",{parentName:"p"},"setStreamPtr")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nmemoryBuffer *outBuf;\n/* . . . populate inBuf . . . */\nif (initialiseAdaptor(&inBuf, &outBuf) != SUCCESS)\n   /* deal with error */\nelse\n{\n    if (saveDocument() != SUCCESS)\n       /* deal with error */\n    else\n       /* continue processing */\n}\n')),Object(b.b)("h2",{id:"319-the-setstreamptr-function"},Object(b.b)("strong",{parentName:"h2"},"3.19 The setStreamPtr Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus setStreamPtr(StreamID_t streamID, memoryBuffer \\*pStream);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"setStreamPtr")," function stores the pointer value in ",Object(b.b)("strong",{parentName:"p"},"pStream")," in\nthe ",Object(b.b)("strong",{parentName:"p"},"streamData")," field in the stream object with stream ID\n",Object(b.b)("strong",{parentName:"p"},"streamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"setStreamPtr")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamPtr")," is NULL, the ",Object(b.b)("strong",{parentName:"p"},"setStreamPtr"),"\nfunction returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nmemoryBuffer \\*outBuf;\n/* . . . populate inBuf . . . */\nif (initialiseAdaptor(&inBuf) != SUCCESS)\n   /* deal with error */\nelse\n{\n    /* initialise streamID and outBuf */\n    . . .\n    if (setStreamPtr(streamID, outbuf) != SUCCESS)\n       /* deal with error */\n    else\n       /* continue processing */\n}\n')),Object(b.b)("h2",{id:"320-the-setstreamsize-function"},Object(b.b)("strong",{parentName:"h2"},"3.20 The setStreamSize Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus setStreamSize(StreamID_t streamID, StreamSize_t \\*streamSize);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"setStreamSize")," function stores the value of ",Object(b.b)("strong",{parentName:"p"},"streamSize")," in the\nstream size field of the stream object with stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"setStreamSize")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamSize")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"streamID"),"\nrefers to a stream marked as deleted, the ",Object(b.b)("strong",{parentName:"p"},"setStreamSize")," function\nreturns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nStreamSize_t streamSize;\nStreamID_t streamID;\n/* initialise streamID and streamSize */\n. . .\nif (setStreamSize(streamID, streamSize) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue processing */\n')),Object(b.b)("h2",{id:"321-the-setobjectrule-function"},Object(b.b)("strong",{parentName:"h2"},"3.21 The setObjectRule Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nStatus setObjectRule(StreamID_t streamID, ObjectRule_t \\*pObjectRule);\n')),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"setObjectRule")," function sets the value of the pointer to the\nobject rule in the object with stream ID ",Object(b.b)("strong",{parentName:"p"},"streamID")," to\n",Object(b.b)("strong",{parentName:"p"},"pObjectRule"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"If successful, the ",Object(b.b)("strong",{parentName:"p"},"setObjectRule")," function returns ",Object(b.b)("strong",{parentName:"p"},"SUCCESS"),"; if a\nsuccessful call to ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor")," has not been made, or\n",Object(b.b)("strong",{parentName:"p"},"streamID")," is invalid, or ",Object(b.b)("strong",{parentName:"p"},"pObjectRule")," is NULL, the\n",Object(b.b)("strong",{parentName:"p"},"setObjectRule")," function returns ",Object(b.b)("strong",{parentName:"p"},"FAIL"),"."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\n. . .\nObjectRuleParamBlock_t parameterBlockForPrePostCameras;\nStreamID_t streamID;\n/* initialise streamID and parameterBlockForPrePostCameras */\n. . .\nif (setObjectRule(parentStreamID, parameterBlockForPrePostCameras.pParentObjectRule) != SUCCESS)\n   /* deal with error */\nelse\n   /* continue\n')),Object(b.b)("h2",{id:"322-the-uninitialiseadaptor-function"},Object(b.b)("strong",{parentName:"h2"},"3.22 The uninitialiseAdaptor Function")),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Synopsis")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nvoid uninitialiseAdaptor(void);\n')),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Description")),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"uninitialiseAdaptor")," removes the structure storage created by\n",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),". The return status to all subsequent calls to\nAdaptor API functions (except ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),", which will return\nFAIL only if its argument is NULL) will be FAIL."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Returns")),Object(b.b)("p",null,"The ",Object(b.b)("strong",{parentName:"p"},"uninitialiseAdaptor")," function returns no value."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"Example")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),'#include "adaptor.h"\nmemoryBuffer inBuf, outBuf;\nif (initialiseAdaptor(&inBuf, &outBuf) != SUCCESS)\n   /* deal with error */\nelse\n   /* . . . do processing . . . */\n. . .\nuninitialiseAdaptor( );\n')),Object(b.b)("h1",{id:"4-example-usage"},Object(b.b)("strong",{parentName:"h1"},"4 EXAMPLE USAGE")),Object(b.b)("h2",{id:"41-navigating-through-a-tree-from-root"},Object(b.b)("strong",{parentName:"h2"},"4.1 Navigating through a tree from root")),Object(b.b)("pre",null,Object(b.b)("code",Object(a.a)({parentName:"pre"},{}),"/* navigateTree: navigate a structured storage and process each node */\nuint32_t navigateTree(StreamID_t parentID, memoryBuffer *pInBuf, memoryBuffer *pOutBuf)\n\n    fileSystemRuleSet->apiFuncPtrs->initialiseAdaptor(pInBuf, pOutBuf);\n\n    /*Get First Child in list of children of the parent Node*/\n    if (fileSystemRuleSet->apiFuncPtrs->getFirstChild(parentID, &nextChildID) == SUCCESS)\n    {\n        /* Test that node existed */\n        if (nextChildID == NOSTREAM)\n            return 0;\n\n        /* do what you have to do with this node */\n        status = processNode(\n                                nextChildID,\n                                parameterBlockForPrePostCameras.pParentObjectRule,\n                                recursionDepth,\n                                &parameterBlockForPrePostCameras,\n                                parentID,\n                                fileSystemRuleSet\n        );\n        while (fileSystemRuleSet->apiFuncPtrs->getNextChild(\n                                                                prevChildID,\n                                                                parentID,\n                                                                &nextChildID) == SUCCESS\n                                                                )\n        {\n            StreamID_t prevChildID = nextChildID;\n\n            if (nextChildID == NOSTREAM)\n                break;\n\n            /* Determine what to do with this node */\n            status = processNode(\n                                    nextChildID,\n                                    parameterBlockForPrePostCameras.pParentObjectRule,\n                                    recursionDepth,\n                                    &parameterBlockForPrePostCameras,\n                                    parentID,\n                                    fileSystemRuleSet\n                                    );\n        }\n\n    }\n    fileSystemRuleSet-\\>apiFuncPtrs-\\>uninitialiseAdaptor( );\n    return status;\n    }\n")),Object(b.b)("h1",{id:"5-summary-of-api-functions"},Object(b.b)("strong",{parentName:"h1"},"5 Summary of API Functions")),Object(b.b)("p",null,"Status ",Object(b.b)("strong",{parentName:"p"},"deleteDescendants"),"(StreamID_t streamID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"deleteStream"),"(StreamID_t streamID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"deleteTree"),"(StreamID_t streamID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"getCLSID"),"(StreamID_t streamID, CLSID_t ",Object(b.b)("em",{parentName:"p"},"classID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"em"},"getFirstChild"),"(StreamID_t parentStreamID, StreamID_t "),"firstChildID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"getName"),"(StreamID_t streamID, String ",Object(b.b)("em",{parentName:"p"},"name);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"em"},"getNextChild"),"(StreamID_t parentStreamID, StreamID_t prevChildID, StreamID_t "),"nextChildID);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"getObjectRule"),"(StreamID_t streamID, ObjectRule_t ",Object(b.b)("strong",{parentName:"p"},"pObjectRule);",Object(b.b)("br",null),"\nStatus "),"getObjectTag",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, ObjectTag_t *objectTag);",Object(b.b)("br",null),"\nStatus "),"getObjectType",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, ObjectType_t *objectType);",Object(b.b)("br",null),"\nStatus "),"getStreamPtr",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, memoryBuffer "),"streamPtr);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"getStreamSize"),"(StreamID_t streamID, StreamSize_t ",Object(b.b)("em",{parentName:"p"},"pStreamSize);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"em"},"getStructuredStorageSize"),"(size_t "),"pSize);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"initialiseAdaptor"),"(memoryBuffer_t ",Object(b.b)("em",{parentName:"p"},"inBuf, memoryBuffer "),"outBuf);",Object(b.b)("br",null),"\nBool ",Object(b.b)("strong",{parentName:"p"},"isNextChild"),"(StreamID_t parentID, StreamID_t prevID);",Object(b.b)("br",null),"\nBool ",Object(b.b)("strong",{parentName:"p"},"isValidObjectType"),"(ObjectType_t objectType);",Object(b.b)("br",null),"\nStatus ",Object(b.b)("strong",{parentName:"p"},"loadStream"),"(StreamID_t streamID, memoryBuffer ",Object(b.b)("strong",{parentName:"p"},"stream);",Object(b.b)("br",null),"\nStatus "),"saveDocument",Object(b.b)("strong",{parentName:"p"},"(void);",Object(b.b)("br",null),"\nStatus "),"setStreamPtr",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, memoryBuffer *streamPtr);",Object(b.b)("br",null),"\nStatus "),"setStreamSize",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, StreamSize_t streamSize);",Object(b.b)("br",null),"\nStatus "),"setObjectRule",Object(b.b)("strong",{parentName:"p"},"(StreamID_t streamID, ObjectRule_t *pObjectRule);",Object(b.b)("br",null),"\nvoid "),"uninitialiseAdaptor**(void);",Object(b.b)("br",null)))}p.isMDXComponent=!0},236:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return j}));var a=n(0),r=n.n(a);function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){b(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=r.a.createContext({}),p=function(e){var t=r.a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=p(e.components);return r.a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,b=e.originalType,c=e.parentName,i=s(e,["components","mdxType","originalType","parentName"]),l=p(n),m=a,j=l["".concat(c,".").concat(m)]||l[m]||u[m]||b;return n?r.a.createElement(j,o(o({ref:t},i),{},{components:n})):r.a.createElement(j,o({ref:t},i))}));function j(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var b=n.length,c=new Array(b);c[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,c[1]=o;for(var i=2;i<b;i++)c[i]=n[i];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);