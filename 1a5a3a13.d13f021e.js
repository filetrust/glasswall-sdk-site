(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{232:function(e,t,a){"use strict";a.d(t,"a",(function(){return o})),a.d(t,"b",(function(){return O}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},o=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),o=p(a),m=n,O=o["".concat(l,".").concat(m)]||o[m]||u[m]||i;return a?r.a.createElement(O,b(b({ref:t},c),{},{components:a})):r.a.createElement(O,b({ref:t},c))}));function O(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=m;var b={};for(var s in t)hasOwnProperty.call(t,s)&&(b[s]=t[s]);b.originalType=e,b.mdxType="string"==typeof e?e:n,l[1]=b;for(var c=2;c<i;c++)l[c]=a[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"},80:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(2),r=a(6),i=(a(0),a(232)),l={title:"Perl Best Practices Summary"},b={unversionedId:"5-development/artifacts/perl_best_practices_summary",id:"5-development/artifacts/perl_best_practices_summary",isDocsHomePage:!1,title:"Perl Best Practices Summary",description:"A list of the complete set of 256 guidelines presented in *Perl Best",source:"@site/docs/5-development/artifacts/perl_best_practices_summary.md",slug:"/5-development/artifacts/perl_best_practices_summary",permalink:"/glasswall-sdk-site/docs/5-development/artifacts/perl_best_practices_summary",version:"current",sidebar:"someSidebar",previous:{title:"Learn YAML in Y minutes",permalink:"/glasswall-sdk-site/docs/5-development/artifacts/LearnYAMLInYMinutes"},next:{title:"CFB Geneology",permalink:"/glasswall-sdk-site/docs/artifacts/CFBGeneology"}},s=[{value:"1. B.1. Chapter 2, Code Layout",id:"1-b1-chapter-2-code-layout",children:[]},{value:"2. B.2. Chapter 3, Naming Conventions",id:"2-b2-chapter-3-naming-conventions",children:[]},{value:"3. B.3. Chapter 4, Values and Expressions",id:"3-b3-chapter-4-values-and-expressions",children:[]},{value:"4. B.4. Variables",id:"4-b4-variables",children:[]},{value:"5. B.5. Control Structures",id:"5-b5-control-structures",children:[]},{value:"6. B.6. Chapter 7, Documentation",id:"6-b6-chapter-7-documentation",children:[]},{value:"7.  B.7. Built-in Functions",id:"7--b7-built-in-functions",children:[]},{value:"8.  B.8. Subroutines",id:"8--b8-subroutines",children:[]},{value:"9.  B.9. Chapter 10, I/O",id:"9--b9-chapter-10-io",children:[]},{value:"10. B.10. References",id:"10-b10-references",children:[]},{value:"11. B.11. Regular Expressions",id:"11-b11-regular-expressions",children:[]},{value:"12. B.12. Error Handling",id:"12-b12-error-handling",children:[]},{value:"13. B.13. Chapter 14, Command-Line Processing",id:"13-b13-chapter-14-command-line-processing",children:[]},{value:"14. B.14. Objects",id:"14-b14-objects",children:[]},{value:"15. B.15. Class Hierarchies",id:"15-b15-class-hierarchies",children:[]},{value:"16. B.16. Modules",id:"16-b16-modules",children:[]},{value:"17. B.17. Testing and Debugging",id:"17-b17-testing-and-debugging",children:[]},{value:"18. B.18. Miscellanea",id:"18-b18-miscellanea",children:[]}],c={rightToc:s};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"A list of the complete set of 256 guidelines presented in ",Object(i.b)("em",{parentName:"p"},"Perl Best\nPractices")," by Damian Conway (2005, O'Reilly). The section heading\nunder which each guideline appears is also provided in square\nbrackets."),Object(i.b)("h2",{id:"1-b1-chapter-2-code-layout"},"1. B.1. Chapter 2, Code Layout"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Brace and parenthesize in K&R style. ","[","Bracketing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Separate your control keywords from the following opening\nbracket. ","[","Keywords","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't separate subroutine or variable names from the following\nopening bracket. ","[","Subroutines and Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Don\'t use unnecessary parentheses for builtins and "honorary"\nbuiltins. ',"[","Builtins","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Separate complex keys or indices from their surrounding\nbrackets. ","[","Keys and Indices","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use whitespace to help binary operators stand out from their\noperands. ","[","Operators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Place a semicolon after every statement. ","[","Semicolons","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Place a comma after every value in a multiline list. ","[","Commas","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use 78-column lines. ","[","Line Lengths","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use four-column indentation levels. ","[","Indentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Indent with spaces, not tabs. ","[","Tabs","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never place two statements on the same line. ","[","Blocks","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Code in paragraphs. ","[","Chunking","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't cuddle an else. ","[","Elses","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Align corresponding items vertically. ","[","Vertical Alignment","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Break long expressions before an operator. ","[","Breaking Long\nLines","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Factor out long expressions in the middle of statements.\n","[","Non-Terminal Expressions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always break a long expression at the operator of the lowest\npossible precedence. ","[","Breaking by Precedence","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Break long assignments before the assignment operator.\n","[","Assignments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Format cascaded ternary operators in columns. ","[","Ternaries","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Parenthesize long lists. ","[","Lists","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Enforce your chosen layout style mechanically. ","[","Automated\nLayout","]"))),Object(i.b)("h2",{id:"2-b2-chapter-3-naming-conventions"},"2. B.2. Chapter 3, Naming Conventions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use grammatical templates when forming identifiers.\n","[","Identifiers","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Name booleans after their associated test. ","[","Booleans","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Mark variables that store references with a ","_","ref suffix.\n","[","Reference Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Name arrays in the plural and hashes in the singular. ","[","Arrays\nand Hashes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use underscores to separate words in multiword identifiers.\n","[","Underscores","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Distinguish different program components by case.\n","[","Capitalization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Abbr idents by prefx. ","[","Abbreviations","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Abbreviate only when the meaning remains unambiguous.\n","[","Ambiguous Abbreviations","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid using inherently ambiguous words in names. ","[","Ambiguous\nNames","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Prefix "for internal use only" subroutines with an underscore.\n',"[","Utility Subroutines","]"))),Object(i.b)("h2",{id:"3-b3-chapter-4-values-and-expressions"},"3. B.3. Chapter 4, Values and Expressions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use interpolating string delimiters only for strings that\nactually interpolate. ","[","String Delimiters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use \"\" or \\'\\' for an empty string. ","[","Empty\nStrings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't write one-character strings in visually ambiguous\nways. ","[","Single-Character Strings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use named character escapes instead of numeric escapes.\n","[","Escaped Characters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use named constants, but Don't use constant. ","[","Constants","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't pad decimal numbers with leading zeros. ","[","Leading\nZeros","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use underscores to improve the readability of long numbers.\n","[","Long Numbers","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Lay out multiline strings over multiple lines. ","[","Multiline\nStrings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a heredoc when a multiline string exceeds two lines.\n","[","Here Documents","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Use a "theredoc" when a heredoc would compromise your\nindentation. ',"[","Heredoc Indentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Make every heredoc terminator a single uppercase identifier\nwith a standard prefix. ","[","Heredoc Terminators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"When introducing a heredoc, quote the terminator. ","[","Heredoc\nQuoters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use barewords. ","[","Barewords","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Reserve =",">"," for pairs. ","[","Fat Commas","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use commas to sequence statements. ","[","Thin Commas","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't mix high- and low-precedence booleans.\n","[","Low-Precedence Operators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Parenthesize every raw list. ","[","Lists","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use table-lookup to test for membership in lists of\nstrings; use any( ) for membership of lists of anything\nelse. ","[","List Membership","]"))),Object(i.b)("h2",{id:"4-b4-variables"},"4. B.4. Variables"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid using non-lexical variables. ","[","Lexical Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use package variables in your own development.\n","[","Package Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If you\\'re forced to modify a package variable, localize\nit. ","[","Localization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Initialize any variable you localize. ","[","Initialization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"use English for the less familiar punctuation variables.\n","[","Punctuation Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If you\\'re forced to modify a punctuation variable,\nlocalize it. ","[","Localizing Punctuation Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use the regex match variables. ","[","Match Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Beware of any modification via \\$","_",". ","[","Dollar-Underscore","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use negative indices when counting from the end of an\narray. ","[","Array Indices","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Take advantage of hash and array slicing. ","[","Slicing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a tabular layout for slices. ","[","Slice Layout","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Factor large key or index lists out of their slices.\n","[","Slice Factoring","]"))),Object(i.b)("h2",{id:"5-b5-control-structures"},"5. B.5. Control Structures"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use block if, not postfix if. ","[","If Blocks","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Reserve postfix if for flow-of-control statements.\n","[","Postfix Selectors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use postfix unless, for, while, or until. ","[","Other\nPostfix Modifiers","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use unless or until at all. ","[","Negative Control\nStatements","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid C-style for statements. ","[","C-Style Loops","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid subscripting arrays or hashes within loops.\n","[","Unnecessary Subscripting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never subscript more than once in a loop. ","[","Necessary\nSubscripting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use named lexicals as explicit for loop iterators.\n","[","Iterator Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always declare a for loop iterator variable with my.\n","[","Non-Lexical Loop Iterators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use map instead of for when generating new lists from old.\n","[","List Generation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use grep and first instead of for when searching for values\nin a list. ","[","List Selections","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use for instead of map when transforming a list in place.\n","[","List Transformation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a subroutine call to factor out complex list\ntransformations. ","[","Complex Mappings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never modify \\$","_"," in a list function. ","[","List Processing\nSide Effects","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid cascading an if. ","[","Multipart Selections","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use table look-up in preference to cascaded equality tests.\n","[","Value Switches","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"When producing a value, use tabular ternaries. ","[","Tabular\nTernaries","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use do",".","..while loops. ","[","do-while Loops","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Reject as many iterations as possible, as early as\npossible. ","[","Linear Coding","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't contort loop structures just to consolidate control.\n","[","Distributed Control","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use for and redo instead of an irregularly counted while.\n","[","Redoing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Label every loop that is exited explicitly, and use the\nlabel with every next, last, or redo. ","[","Loop Labels","]"))),Object(i.b)("h2",{id:"6-b6-chapter-7-documentation"},"6. B.6. Chapter 7, Documentation"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Distinguish user documentation from technical\ndocumentation. ","[","Types of Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Create standard POD templates for modules and applications.\n","[","Boilerplates","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Extend and customize your standard POD templates.\n","[","Extended Boilerplates","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Put user documentation in source files. ","[","Location","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Keep all user documentation in a single place within your\nsource file. ","[","Contiguity","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Place POD as close as possible to the end of the file.\n","[","Position","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Subdivide your technical documentation appropriately.\n","[","Technical Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use block templates for major comments. ","[","Comments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use full-line comments to explain the algorithm.\n","[","Algorithmic Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use end-of-line comments to point out subtleties and\noddities. ","[","Elucidating Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Comment anything that has puzzled or tricked you.\n","[","Defensive Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider whether it\\'s better to rewrite than to comment.\n","[","Indicative Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Use "invisible" POD sections for longer technical\ndiscussions. ',"[","Discursive Documentation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Check the spelling, syntax, and sanity of your\ndocumentation. ","[","Proofreading","]"))),Object(i.b)("h2",{id:"7--b7-built-in-functions"},"7.  B.7. Built-in Functions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't recompute sort keys inside a sort. ","[","Sorting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use reverse to reverse a list. ","[","Reversing Lists","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use scalar reverse to reverse a scalar. ","[","Reversing\nScalars","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use unpack to extract fixed-width fields. ","[","Fixed-Width\nData","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use split to extract simple variable-width fields.\n","[","Separated Data","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use Text::CSV_XS to extract complex variable-width fields.\n","[","Variable-Width Data","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid string eval. ","[","String Evaluations","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider building your sorting routines with Sort::Maker.\n","[","Automating Sorts","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use 4-arg substr instead of lvalue substr. ","[","Substrings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Make appropriate use of lvalue values. ","[","Hash Values","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use glob, not \\<",".","..",">",". ","[","Globbing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid a raw select for non-integer sleeps. ","[","Sleeping","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use a block with a map and grep. ","[","Mapping and\nGrepping","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Use the "non-builtin builtins". ',"[","Utilities","]"))),Object(i.b)("h2",{id:"8--b8-subroutines"},"8.  B.8. Subroutines"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Call subroutines with parentheses but without a leading &.\n","[","Call Syntax","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't give subroutines the same names as built-in\nfunctions. ","[","Homonyms","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always unpack \\@","_"," first. ","[","Argument Lists","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a hash of named arguments for any subroutine that has\nmore than three parameters. ","[","Named Arguments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use definedness or existence to test for missing arguments.\n","[","Missing Arguments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Resolve any default argument values as soon as \\@","_"," is\nunpacked. ","[","Default Argument Values","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always return scalar in scalar returns. ","[","Scalar Return\nValues","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Make list-returning subroutines return the "obvious"\nvalue in scalar context. ',"[","Contextual Return Values","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'When there is no "obvious" scalar context return value,\nconsider Contextual::Return instead. ',"[","Multi-Contextual\nReturn Values","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use subroutine prototypes. ","[","Prototypes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always return via an explicit return. ","[","Implicit Returns","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a bare return to return failure. ","[","Returning Failure","]"))),Object(i.b)("h2",{id:"9--b9-chapter-10-io"},"9.  B.9. Chapter 10, I/O"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use bareword filehandles. ","[","Filehandles","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use indirect filehandles. ","[","Indirect Filehandles","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If you have to use a package filehandle, localize it first.\n","[","Localizing Filehandles","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use either the IO::File module or the three-argument form\nof open. ","[","Opening Cleanly","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never open, close, or print to a file without checking the\noutcome. ","[","Error Checking","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Close filehandles explicitly, and as soon as possible.\n","[","Cleanup","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use while (\\<",">","), not for (\\<",">","). ","[","Input Loops","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prefer line-based I/O to slurping. ","[","Line-Based Input","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Slurp a filehandle with a do block for purity. ","[","Simple\nSlurping","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Slurp a stream with Perl6::Slurp for power and simplicity.\n","[","Power Slurping","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid using ","*","STDIN, unless you really mean it. ","[","Standard\nInput","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always put filehandles in braces within any print\nstatement. ","[","Printing to Filehandles","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always prompt for interactive input. ","[","Simple Prompting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't reinvent the standard test for interactivity.\n","[","Interactivity","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use the IO::Prompt module for prompting. ","[","Power\nPrompting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always convey the progress of long non-interactive\noperations within interactive applications. ","[","Progress\nIndicators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider using the Smart::Comments module to automate your\nprogress indicators. ","[","Automatic Progress Indicators","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Avoid a raw select when setting autoflushes.\n","[","Autoflushing","]"))),Object(i.b)("h2",{id:"10-b10-references"},"10. B.10. References"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Wherever possible, dereference with arrows.\n","[","Dereferencing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Where prefix dereferencing is unavoidable, put braces\naround the reference. ","[","Braced References","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never use symbolic references. ","[","Symbolic References","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use weaken to prevent circular data structures from leaking\nmemory. ","[","Cyclic References","]"))),Object(i.b)("h2",{id:"11-b11-regular-expressions"},"11. B.11. Regular Expressions"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use the /x flag. ","[","Extended Formatting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use the /m flag. ","[","Line Boundaries","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use ","\\","A and ","\\","z as string boundary anchors. ","[","String\nBoundaries","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use ","\\","z, not ","\\",'Z, to indicate "end of string". ',"[","End of\nString","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use the /s flag. ","[","Matching Anything","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider mandating the Regexp::Autoflags module. ","[","Lazy Flags","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use m{",".","..} in preference to /",".","../ in multiline regexes.\n","[","Brace Delimiters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use any delimiters other than /",".","../ or m{",".","..}. ","[","Other\nDelimiters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prefer singular character classes to escaped metacharacters.\n","[","Metacharacters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prefer named characters to escaped metacharacters. ","[","Named\nCharacters","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prefer properties to enumerated character classes.\n","[","Properties","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider matching arbitrary whitespace, rather than specific\nwhitespace characters. ","[","Whitespace","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Be specific when matching "as much as possible".\n',"[","Unconstrained Repetitions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use capturing parentheses only when you intend to capture.\n","[","Capturing Parentheses","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use the numeric capture variables only when you\\'re sure that\nthe preceding match succeeded. ","[","Captured Values","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always give captured substrings proper names. ","[","Capture\nVariables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Tokenize input using the /gc flag. ","[","Piecewise Matching","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Build regular expressions from tables. ","[","Tabular Regexes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Build complex regular expressions from simpler pieces.\n","[","Constructing Regexes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider using Regexp::Common instead of writing your own\nregexes. ","[","Canned Regexes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use character classes instead of single-character\nalternations. ","[","Alternations","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Factor out common affixes from alternations. ","[","Factoring\nAlternations","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prevent useless backtracking. ","[","Backtracking","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Prefer fixed-string eq comparisons to fixed-pattern regex\nmatches. ","[","String Comparisons","]"))),Object(i.b)("h2",{id:"12-b12-error-handling"},"12. B.12. Error Handling"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Throw exceptions instead of returning special values or\nsetting flags. ","[","Exceptions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Make failed builtins throw exceptions too. ","[","Builtin\nFailures","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Make failures fatal in all contexts. ","[","Contextual Failure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Be careful when testing for failure of the system builtin.\n","[","Systemic Failure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Throw exceptions on all failures, including recoverable\nones. ","[","Recoverable Failure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Have exceptions report from the caller\\'s location, not\nfrom the place where they were thrown. ","[","Reporting\nFailure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Compose error messages in the recipient\\'s dialect. ","[","Error\nMessages","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Document every error message in the recipient\\'s dialect.\n","[","Documenting Errors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use exception objects whenever failure data needs to be\nconveyed to a handler. ","[","OO Exceptions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use exception objects when error messages may change.\n","[","Volatile Error Messages","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use exception objects when two or more exceptions are\nrelated. ","[","Exception Hierarchies","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Catch exception objects in most-derived-first order.\n","[","Processing Exceptions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Build exception classes automatically. ","[","Exception\nClasses","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Unpack the exception variable in extended exception\nhandlers. ","[","Unpacking Exceptions","]"))),Object(i.b)("h2",{id:"13-b13-chapter-14-command-line-processing"},"13. B.13. Chapter 14, Command-Line Processing"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Enforce a single consistent command-line structure.\n","[","Command-Line Structure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Adhere to a standard set of conventions in your\ncommand-line syntax. ","[","Command-Line Conventions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Standardize your meta-options. ","[","Meta-options","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Allow the same filename to be specified for both input and\noutput. ","[","In-situ Arguments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Standardize on a single approach to command-line\nprocessing. ","[","Command-Line Processing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Ensure that your interface, run-time messages, and\ndocumentation remain consistent. ","[","Interface Consistency","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Factor out common command-line interface components into a\nshared module. ","[","Interapplication Consistency","]"))),Object(i.b)("h2",{id:"14-b14-objects"},"14. B.14. Objects"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Make object orientation a choice, not a default. ","[","Using\nOO","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Choose object orientation using appropriate criteria.\n","[","Criteria","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use pseudohashes. ","[","Pseudohashes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use restricted hashes. ","[","Restricted Hashes","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use fully encapsulated objects. ","[","Encapsulation","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Give every constructor the same standard name.\n","[","Constructors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't let a constructor clone objects. ","[","Cloning","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always provide a destructor for every inside-out class.\n","[","Destructors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"When creating methods, follow the general guidelines for\nsubroutines. ","[","Methods","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Provide separate read and write accessors. ","[","Accessors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use lvalue accessors. ","[","Lvalue Accessors","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use the indirect object syntax. ","[","Indirect Objects","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Provide an optimal interface, rather than a minimal one.\n","[","Class Interfaces","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Overload only the isomorphic operators of algebraic\nclasses. ","[","Operator Overloading","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always consider overloading the boolean, numeric, and\nstring coercions of objects. ","[","Coercions","]"))),Object(i.b)("h2",{id:"15-b15-class-hierarchies"},"15. B.15. Class Hierarchies"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't manipulate the list of base classes directly.\n","[","Inheritance","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use distributed encapsulated objects. ","[","Objects","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never use the one-argument form of bless. ","[","Blessing\nObjects","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Pass constructor arguments as labeled values, using a hash\nreference. ","[","Constructor Arguments","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Distinguish arguments for base classes by class name as\nwell. ","[","Base Class Initialization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Separate your construction, initialization, and destruction\nprocesses. ","[","Construction and Destruction","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Build the standard class infrastructure automatically.\n","[","Automating Class Hierarchies","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use Class::Std to automate the deallocation of attribute\ndata. ","[","Attribute Demolition","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Have attributes initialized and verified automatically.\n","[","Attribute Building","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Specify coercions as :STRINGIFY, :NUMERIFY, and :BOOLIFY\nmethods. ","[","Coercions","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use :CUMULATIVE methods instead of SUPER:: calls.\n","[","Cumulative Methods","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use AUTOLOAD( ). ","[","Autoloading","]"))),Object(i.b)("h2",{id:"16-b16-modules"},"16. B.16. Modules"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Design the module\\'s interface first. ","[","Interfaces","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Place original code inline. Place duplicated code in a\nsubroutine. Place duplicated subroutines in a module.\n","[","Refactoring","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use three-part version numbers. ","[","Version Numbers","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Enforce your version requirements programmatically.\n","[","Version Requirements","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Export judiciously and, where possible, only by request.\n","[","Exporting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Consider exporting declaratively. ","[","Declarative Exporting","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never make variables part of a module\\'s interface.\n","[","Interface Variables","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Build new module frameworks automatically. ","[","Creating\nModules","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use core modules wherever possible. ","[","The Standard\nLibrary","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use CPAN modules where feasible. ","[","CPAN","]"))),Object(i.b)("h2",{id:"17-b17-testing-and-debugging"},"17. B.17. Testing and Debugging"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Write the test cases first. ","[","Test Cases","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Standardize your tests with Test::Simple or Test::More.\n","[","Modular Testing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Standardize your test suites with Test::Harness. ","[","Test\nSuites","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Write test cases that fail. ","[","Failure","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Test both the likely and the unlikely. ","[","What to Test","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Add new test cases before you start debugging. ","[","Debugging\nand Testing","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always use strict. ","[","Strictures","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Always turn on warnings explicitly. ","[","Warnings","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Never assume that a warning-free compilation implies\ncorrectness. ","[","Correctness","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Turn off strictures or warnings explicitly, selectively,\nand in the smallest possible scope. ","[","Overriding\nStrictures","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Learn at least a subset of the perl debugger. ","[","The\nDebugger","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Use serialized warnings when debugging "manually".\n',"[","Manual Debugging","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},'Consider using "smart comments" when debugging, rather\nthan warn statements. ',"[","Semi-Automatic Debugging","]"))),Object(i.b)("h2",{id:"18-b18-miscellanea"},"18. B.18. Miscellanea"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Use a revision control system. ","[","Revision Control","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Integrate non-Perl code into your applications via the\nInline:: modules. ","[","Other Languages","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Keep your configuration language uncomplicated.\n","[","Configuration Files","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't use formats. ","[","Formats","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't tie variables or filehandles. ","[","Ties","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't be clever. ","[","Cleverness","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"If you must rely on cleverness, encapsulate it.\n","[","Encapsulated Cleverness","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't optimize codebenchmark it. ","[","Benchmarking","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't optimize data structuresmeasure them. ","[","Memory","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Look for opportunities to use caches. ","[","Caching","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Automate your subroutine caching. ","[","Memoization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Benchmark any caching strategy you use. ","[","Caching for\nOptimization","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Don't optimize applicationsprofile them. ","[","Profiling","]")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Be careful to preserve semantics when refactoring syntax.\n","[","Enbugging","]"))))}p.isMDXComponent=!0}}]);